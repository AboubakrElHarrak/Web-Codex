{
    "url": "https://en.wikipedia.org/wiki/Software_code",
    "title": "Computer program",
    "table_of_contents": [
        "1 History",
        "1.1 Analytical Engine",
        "1.2 Universal Turing machine",
        "1.3 Relay-based computers",
        "1.4 ENIAC",
        "1.5 Stored-program computers",
        "2 Programming languages",
        "2.1 Hello world program",
        "2.2 Generation of programming languages",
        "2.3 Imperative languages",
        "2.3.1 Fortran",
        "2.3.2 COBOL",
        "2.3.3 Algol",
        "2.3.4 Basic",
        "2.3.5 C",
        "2.3.6 C++",
        "2.4 Declarative languages",
        "2.4.1 Lisp",
        "2.4.2 ML",
        "2.4.3 Prolog",
        "3 Program modules",
        "3.1 Cohesion",
        "3.2 Coupling",
        "3.3 Data flow analysis",
        "3.4 Object-oriented programming",
        "4 Functional categories",
        "4.1 Application software",
        "4.2 Operating system",
        "4.2.1 Kernel Program",
        "4.2.2 Interrupts",
        "4.3 Utility program",
        "4.4 Boot program",
        "4.5 Embedded program",
        "4.6 Microcode program",
        "5 See also",
        "6 References"
    ],
    "content": [
        {
            "paragraph1": "In imperative programming, a computer program is a sequence of instructions in a programming language that a computer can execute or interpret. In declarative programming, a computer program is a set of instructions.\n",
            "paragraph2": "A computer program in its human-readable form is called source code. Source code needs another computer program to execute because computers can only execute their native machine instructions. Therefore, source code may be translated to machine instructions using the language's compiler. (Machine language programs are translated using an assembler.) The resulting file is called an executable. Alternatively, source code may execute within the language's interpreter. The programming language Java compiles into an a intermediate form which is then executed by a Java interpreter.\n",
            "paragraph3": "If the executable is requested for execution, then the operating system loads it into memory and starts a process. The central processing unit will soon switch to this process so it can fetch, decode, and then execute each machine instruction.\n",
            "paragraph4": "If the source code is requested for execution, then the operating system loads the corresponding interpreter into memory and starts a process. The interpreter then loads the source code into memory to translate and execute each statement. Running the source code is slower than running an executable. Moreover, the interpreter must be installed on the computer.\n"
        },
        {
            "title": "History",
            "subtitle1": "Analytical Engine",
            "image1": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Diagram_for_the_computation_of_Bernoulli_numbers.jpg/440px-Diagram_for_the_computation_of_Bernoulli_numbers.jpg",
                "caption": "\n\t\tLovelace's diagram from Note G, the first published computer algorithm\n"
            },
            "paragraph1": "In 1837, Charles Babbage was inspired by Jacquard's loom to attempt to build the Analytical Engine.\nThe names of the components of the calculating device were borrowed from the textile industry. In the textile industry, yarn was brought from the store to be milled. The device had a \"store\" which was memory to hold 1,000 numbers of 50 decimal digits each. Numbers from the \"store\" were transferred to the \"mill\" for processing. It was programmed using two sets of perforated cards. One set to direct the operation and the other for the input variables.\n However, after more than 17,000 pounds of the British government's money, the thousands of cogged wheels and gears never fully worked together.\n",
            "paragraph2": "During a nine-month period in 1842–43, Ada Lovelace translated the memoir of Italian mathematician Luigi Menabrea. The memoir covered the Analytical Engine. The translation contained Note G which completely detailed a method for calculating Bernoulli numbers using the Analytical Engine. This note is recognized by some historians as the world's first published computer program.\n",
            "subtitle2": "Universal Turing machine",
            "paragraph3": "In 1936, Alan Turing introduced the Universal Turing machine—a theoretical device that can model every computation that can be performed on a Turing complete computing machine.\nIt is a finite-state machine that has an infinitely long read/write tape. The machine can move the tape back and forth, changing its contents as it performs an algorithm. The machine starts in the initial state, goes through a sequence of steps, and halts when it encounters the halt state.\n",
            "subtitle3": "Relay-based computers",
            "paragraph4": "The Z3 computer, invented by Konrad Zuse (1941), was a digital and programmable computer. Zuse became aware of the \"Babbage Engine\" in 1939 while attempting to file a German patent. The Analytical Engine was base-10 — which was easy to comprehend. Zuse recognized that a binary machine was easy to construct. Telephone relays are two-position switches — open or closed. The Z3 had approximately 2,600 relays: 1,800 for the memory, 600 for the arithmetic, and 200 for the punch tape reader, keyboard, and display. The circuits provided a floating-point, nine-instruction computer. Programming the Z3 was through a specially designed keyboard and punch tape. Manual input was through a calculator-style keyboard that accepted decimal numbers. The machine converted the input to binary and passed them through a series of calculating modules. The result was converted back to decimal and displayed on an output panel.\n",
            "paragraph5": "Simultaneously developed was its successor — the Z4 computer. (An air-raid on April 6, 1945 destroyed the Z3.) In 1950, the Z4 was placed into production at the Federal Technical Institute in Zurich.\n",
            "paragraph6": "The Harvard Mark I, invented by IBM (1944), also was a digital and programmable computer. The computer supported 23 signed integer digits and had seven major units:\n",
            "ul1": "One unit had 60 sets of dial switches that were used to set application constants.\nOne unit was used to direct the machine's operations.\nOne unit performed addition and subtraction and had 72 registers used to store the intermediate results.\nOne unit was used to perform multiplication and division.\nOne unit was used to calculate trigonometric  functions using interpolation.\nOne unit was used to calculate logarithmic functions using interpolation.\nOne unit was used to direct the machine's output medium — either typewriter printer or punched card printer.\n",
            "paragraph7": "The Harvard Mark I had 3,304 relays and 530 miles of wire. Two punched tape readers provided input. One reader inputted the instructions. A code book was written by Howard H. Aiken that indexed the available algorithms. From this book, a programmer punched the coded instructions onto a tape. The other reader inputted the data to be processed.\n",
            "paragraph8": "The Harvard Mark I was succeeded by IBM's two other relay-based computers:\n",
            "ul2": "the Harvard Mark II.\nthe Selective Sequence Electronic Calculator (SSEC). The SSEC operated until August 1952.\n",
            "subtitle4": "ENIAC",
            "image3": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/e/e5/ENIAC-changing_a_tube.jpg/440px-ENIAC-changing_a_tube.jpg",
                "caption": "\n\t\tGlenn A. Beck is changing a tube in ENIAC.\n\t"
            },
            "paragraph9": "The Electronic Numerical Integrator And Computer (ENIAC) was built between July 1943 and Fall 1945. It was a Turing complete, general-purpose computer that used 17,468 vacuum tubes to create the circuits. At its core, it was a series of Pascalines wired together. Its 40 units weighed 30 tons, occupied 1,800 square feet (167 m2), and consumed $650 per hour (in 1940s currency) in electricity when idle. It had 20 base-10 accumulators. Programming the ENIAC took up to two months. Three function tables were on wheels and needed to be rolled to fixed function panels. Function tables were connected to function panels using heavy black cables. Each function table had 728 rotating knobs. Programming the ENIAC also involved setting some of the 3,000 switches. Debugging a program took a week. It ran from 1947 until 1955 at Aberdeen Proving Ground, calculating hydrogen bomb parameters, predicting weather patterns, and producing firing tables to aim artillery guns.\n",
            "subtitle5": "Stored-program computers",
            "paragraph10": "Instead of plugging in cords and turning switches, a stored-program computer loads its instructions into memory just like it loads its data into memory. As a result, the computer could be programmed quickly and perform calculations at very fast speeds. Presper Eckert and John Mauchly built the ENIAC. The two engineers introduced the stored-program concept in a three-page memo dated February 1944. Later, in September 1944, Dr. John von Neumann began working on the ENIAC project. On June 30, 1945, von Neumann published the First Draft of a Report on the EDVAC which equated the structures of the computer with the structures of the human brain. The design became known as the von Neumann architecture. The architecture was simultaneously deployed in the constructions of the EDVAC and EDSAC computers in 1949.\n",
            "paragraph11": "In 1961, the Burroughs B5000 was built specifically to be programmed in the Algol 60 language. The hardware featured circuits to ease the compile phase.\n",
            "paragraph12": "In 1964, the IBM System/360 was a line of six computers each having the same instruction set architecture. The Model 30 was the smallest and least expensive. Customers could upgrade and retain the same application software. The Model 75 was the most premium.  Each System/360 model featured multiprogramming — having multiple processes in memory at once. When one process was waiting for input/output, another could compute.\n",
            "paragraph13": "IBM planned for each model to be programmed using PL/1. A committee was formed that included COBOL, Fortran and ALGOL programmers. The purpose was to develop a language that was comprehensive, easy to use, extendible, and would replace Cobol and Fortran. The result was a large and complex language that took a long time to compile.\n",
            "image4": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/9/99/Dg-nova3.jpg/440px-Dg-nova3.jpg",
                "caption": "\n\t\tSwitches for manual input on a Data General Nova 3, manufactured in the mid-1970s\n\t"
            },
            "paragraph14": "Computers manufactured until the 1970s had front-panel switches for manual programming. The computer program was written on paper for reference. An instruction was represented by a configuration of on/off settings. After setting the configuration, an execute button was pressed. This process was then repeated. Computer programs also were automatically inputted via paper tape or punched cards. After the medium was loaded, the starting address was set via switches, and the execute button was pressed.\n"
        },
        {
            "title": "Programming languages",
            "paragraph1": "Computer programming (also known as software development and software engineering) is the process of writing or editing source code. In a formal  environment, a systems analyst will gather information from managers about all the business processes to automate. This professional then prepares a detailed plan for the new or modified system. The plan is analogous to an architect's blueprint. A computer programmer is a specialist responsible for writing or modifying the source code to implement the detailed plan.\n",
            "subtitle1": "Hello world program",
            "image1": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/2/21/Hello_World_Brian_Kernighan_1978.jpg/440px-Hello_World_Brian_Kernighan_1978.jpg",
                "caption": "\n\t\t\"Hello, World!\" computer program by Brian Kernighan (1978)\n\t"
            },
            "paragraph2": "The \"Hello, World!\" program is a few instructions used to illustrate the basic output rules of a programming language.\n",
            "paragraph3": "A programming language is a set of keywords, symbols, identifiers, and rules by which programmers can communicate instructions to the computer. They follow a set of rules called a syntax.\n",
            "ul1": "Keywords are reserved words to form declarations and statements.\nSymbols are characters to form operations, assignments, control flow, and delimiters.\nIdentifiers are words created by programmers to form constants, variable names, structure names, and function names.\nSyntax Rules are defined in the Backus–Naur form.\n",
            "paragraph4": "Programming languages get their basis from formal languages. The purpose of defining a solution in terms of its formal language is to generate an algorithm to solve the underlining problem. An algorithm is a sequence of simple instructions that solve a problem.\n",
            "subtitle2": "Generation of programming languages",
            "paragraph5": "The evolution of programming languages began when the EDSAC (1949) used the first stored computer program in its von Neumann architecture. Programming the EDSAC was in the first generation of programming languages.\n",
            "ul2": "The first generation of programming languages is machine language.[33] Machine language requires the programmer to enter instructions using instruction numbers called machine code. For example, the ADD operation on the PDP-11 has instruction number 24576.[34]\n",
            "ul3": "The second generation of programming languages is assembly language.[33] Assembly language allows the programmer to use mnemonic instructions instead of remembering instruction numbers. An assembler translates each assembly language mnemonic into its machine language number. For example, on the PDP-11, the operation 24576 can be referenced as ADD in the source code.[34] The four basic arithmetic operations have assembly instructions like ADD, SUB, MUL, and DIV.[34] Computers also have instructions like DW (Define Word) to reserve memory cells. Then the MOV instruction can copy integers between registers and memory.\n",
            "ul4": "The third generation of programming languages use compilers and interpreters to execute computer programs. Unlike assembly language, these languages generate many machine language instructions for each symbolic statement.[33] The distinguishing feature of third generation languages is their independence from a particular hardware.[37] They began with the languages of Fortran (1958), COBOL (1959), ALGOL (1960), and BASIC (1964).[33] In 1973, C emerged as a high-level language that produced efficient machine language instructions.[38] Today, an entire paradigm of languages fill the imperative third generation spectrum.\n",
            "ul5": "The fourth generation of programming languages emphasize what output results are desired, rather than how programming statements should be constructed.[33] Declarative languages attempt to limit side effects and allow programmers to write code with relatively few errors.[33] One popular fourth generation language is called Structured Query Language (SQL).[33] Database developers no longer need to process each database record one at a time. Also, a simple instruction can generate output records without having to understand how it's retrieved.\n",
            "ul6": "The fifth generation of programming languages use visual tools to generate source code.[39] An integrated development environment allows the programmer to draw the graphical user interface (GUI) on the screen using a mouse. The programmer writes event handling functions that will be executed when fields are hovered over, entered into, or exited from. The development system couples the functions to the GUI and outputs a computer program.[40]\n",
            "subtitle3": "Imperative languages",
            "image2": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/3/37/Object-Oriented-Programming-Methods-And-Classes-with-Inheritance.png/440px-Object-Oriented-Programming-Methods-And-Classes-with-Inheritance.png",
                "caption": "\n\t\tA computer program written in an imperative language\n\t"
            },
            "paragraph6": "Imperative languages specify a sequential algorithm using declarations, expressions, and statements:\n",
            "ul7": "A declaration introduces a variable name to the computer program and assigns it to a datatype[42] – for example: var x: integer;\nAn expression yields a value – for example: 2 + 2 yields 4\nA statement might assign an expression to a variable or use the value of a variable to alter the program's control flow – for example: x := 2 + 2; if x = 4 then do_something();\n",
            "paragraph7": "FORTRAN (1958) was unveiled as \"The IBM Mathematical FORmula TRANslating system.\" It first compiled correctly in 1958. It was designed for scientific calculations, without string handling facilities. Along with declarations, expressions and statements, it supported:\n",
            "ul8": "arrays.\nsubroutines.\n\"do\" loops.\n",
            "paragraph8": "It succeeded because:\n",
            "ul9": "programming and debugging costs were below computer running costs.\nit was supported by IBM.\napplications at the time were scientific.[43]\n",
            "paragraph9": "However, non IBM vendors also wrote Fortran compilers, but with a syntax that would likely fail IBM's compiler. The American National Standards Institute (ANSI) developed the first Fortran standard in 1966. In 1978, Fortran 77 became the standard until 1991. Fortran 90 supports:\n",
            "ul10": "records.\npointers to arrays.\n",
            "paragraph10": "COBOL (1959) stands for \"COmmon Business Oriented Language.\" Fortran manipulated symbols. It was soon realized that symbols didn't need to be numbers, so strings were introduced. The US Department of Defense influenced COBOL's development, with Grace Hopper being a major contributor. The statements were English-like and verbose. The goal was to design a language so managers could read the programs. However, the lack of structured statements hindered this goal.\n",
            "paragraph11": "COBOL's development was tightly controlled, so dialects didn't emerge to require ANSI standards. As a consequence, it wasn't changed for 25 years until 1974. The 1990s version did make consequential changes like object-oriented programming.\n",
            "paragraph12": "ALGOL (1960) stands for \"ALGOrithmic Language.\" It had a profound influence on programming language design. Emerging from a committee of European and American programming language experts, it used standard mathematical notation and had a readable structured design. Algol was first to define its syntax using the Backus–Naur form. This led to syntax-directed compilers. It added features like:\n",
            "ul11": "block structure, where variables were local to their block.\narrays with variable bounds.\n\"for\" loops.\nfunctions.\nrecursion.[46]\n",
            "paragraph13": "Algol's direct descendants include Pascal, Modula-2, Ada, Delphi and Oberon on one branch. On another branch there's C, C++ and Java.\n",
            "paragraph14": "BASIC (1964) stands for \"Beginner's All Purpose Symbolic Instruction Code.\" It was developed at Dartmouth College for all of their students to learn. If a student didn't go on to a more powerful language, the student would still remember Basic. A Basic interpreter was installed in the microcomputers manufactured in the late 1970s. As the microcomputer industry grew, so did the language.\n",
            "paragraph15": "Basic pioneered the interactive session. It offered operating system commands within its environment:\n",
            "ul12": "The 'new' command created an empty slate.\nStatements evaluated immediately.\nStatements could be programmed by preceding them with a line number.\nThe 'list' command displayed the program.\nThe 'run' command executed the program.\n",
            "paragraph16": "However, the Basic syntax was too simple for large programs. Recent dialects have added structure and object-oriented extensions. Microsoft's Visual Basic is still widely used and produces a graphical user interface.\n",
            "paragraph17": " C programming language (1973) got its name because the language BCPL was replaced with B, and AT&T Bell Labs called the next version \"C.\" Its purpose was to write the UNIX operating system. C is a relatively small language -- making it easy to write compilers. Its growth mirrored the hardware growth in the 1980s. Its growth also was because it has the facilities of assembly language, but uses a high-level syntax. It added advanced features like:\n",
            "ul13": "inline assembler.\narithmetic on pointers.\npointers to functions.\nbit operations.\nfreely combining complex operators.[38]\n",
            "image3": {
                "url": "//upload.wikimedia.org/wikipedia/commons/9/93/Computer-memory-map.png",
                "caption": "\n\t\tComputer memory map\n\t"
            },
            "paragraph18": "C allows the programmer to control which region of memory data is to be stored. Global variables and static variables require the fewest clock cycles to store. The stack is automatically used for the standard variable declarations. Heap memory is returned to a pointer variable from the malloc() function.\n",
            "ul14": "The global and static data region is located just above the program region. (The program region is technically called the text region. It's where machine instructions are stored.)\n",
            "ul15": "The stack region is a contiguous block of memory located near the top memory address.[52] Variables placed in the stack, ironically, are populated from top to bottom.[52] A stack pointer is a special-purpose register that keeps track of the last memory address populated.[52] Variables are placed into the stack via the assembly language PUSH instruction. Therefore, the addresses of these variables are set during runtime. The method for stack variables to lose their scope is via the POP instruction.\n",
            "ul16": "The heap region is located below the stack.[49] It is populated from the bottom to the top. The operating system manages the heap using a heap pointer and a list of allocated memory blocks.[54] Like the stack, the addresses of heap variables are set during runtime. Out of memory errors occur when the heap pointer and the stack pointer meet.\n",
            "paragraph19": "In the 1970s, software engineers needed language support to break large projects down into modules. One obvious feature was to decompose large projects physically into separate files. A less obvious feature was to decompose large projects logically into abstract datatypes. At the time, languages supported concrete (scalar) datatypes like integer numbers, floating-point numbers, and strings of characters. Concrete datatypes have their representation as part of their name. Abstract datatypes are structures of concrete datatypes — with a new name assigned. For example, a list of integers could be called integer_list.\n",
            "paragraph20": "In object-oriented jargon, abstract datatypes are called classes. However, a class is only a definition; no memory is allocated. When memory is allocated to a class, it's called an object.\n",
            "paragraph21": "Object-oriented imperative languages developed by combining the need for classes and the need for safe functional programming. A function, in an object-oriented language, is assigned to a class. An assigned function is then referred to as a method, member function, or operation. Object-oriented programming is executing operations on objects.\n",
            "paragraph22": "Object-oriented languages support a syntax to model subset/superset relationships. In set theory, an element of a subset inherits all the attributes contained in the superset. For example, a student is a person. Therefore, the set of students is a subset of the set of persons. As a result, students inherit all the attributes common to all persons. Additionally, students have unique attributes that other persons don't have. Object-oriented languages model subset/superset relationships using inheritance. Object-oriented programming became the dominant language paradigm by the late 1990s.\n",
            "paragraph23": "C++ (1985) was originally called \"C with Classes.\" It was designed to expand C's capabilities by adding the object-oriented facilities of the language Simula.\n",
            "paragraph24": "An object-oriented module is composed of two files. The definitions file is called the header file. Here is a C++ header file for the GRADE class in a simple school application:\n",
            "paragraph25": "A constructor operation is a function with the same name as the class name. It is executed when the calling operation executes the new statement.\n",
            "paragraph26": "A module's other file is the source file. Here is a C++ source file for the GRADE class in a simple school application:\n",
            "paragraph27": "Here is a C++ header file for the PERSON class in a simple school application:\n",
            "paragraph28": "Here is a C++ source code for the PERSON class in a simple school application:\n",
            "paragraph29": "Here is a C++ header file for the STUDENT class in a simple school application:\n",
            "paragraph30": "Here is a C++ source code for the STUDENT class in a simple school application:\n",
            "paragraph31": "Here is a driver program for demonstration:\n",
            "paragraph32": "Here is a makefile to compile everything:\n",
            "subtitle4": "Declarative languages",
            "paragraph33": "Imperative languages have one major criticism: assigning an expression to a non-local variable may produce an unintended side effect. Declarative languages generally omit the assignment statement and the control flow. They describe what computation should be performed and not how to compute it. Two broad categories of declarative languages are functional languages and logical languages.\n",
            "paragraph34": "The principle behind a functional language is to use lambda calculus as a guide for a well defined semantic. In mathematics, a function is a rule that maps elements from an expression to a range of values. Consider the function:\n",
            "paragraph35": "times_10(x) = 10 * x\n",
            "paragraph36": "The expression 10 * x is mapped by the function times_10() to a range of values. One value happens to be 20. This occurs when x is 2. So, the application of the function is mathematically written as:\n",
            "paragraph37": "times_10(2) = 20\n",
            "paragraph38": "A functional language compiler will not store this value in a variable. Instead, it will push the value onto the computer's stack before setting the program counter back to the calling function. The calling function will then pop the value from the stack.\n",
            "paragraph39": "Imperative languages do support functions. Therefore, functional programming can be achieved in an imperative language, if the programmer uses discipline. However, functional languages force this discipline onto the programmer through its syntax. Functional languages have a syntax tailored to emphasize the what.\n",
            "paragraph40": "A functional program is developed with a set of primitive functions followed by a single driver function. Consider the snippet:\n",
            "paragraph41": "function max(a,b){ /* code omitted */}\n",
            "paragraph42": "function min(a,b){ /* code omitted */}\n",
            "paragraph43": "function difference_between_largest_and_smallest(a,b,c) {\n",
            "paragraph44": "}\n",
            "paragraph45": "The primitives are max() and min(). The driver function is difference_between_largest_and_smallest(). Executing:\n",
            "paragraph46": "put(difference_between_largest_and_smallest(10,4,7)); will output 6.\n",
            "paragraph47": "Functional languages are used in computer science research to explore new language features. Moreover, their lack of side-effects have made them popular in parallel programming and concurrent programming. However, application developers prefer the object-oriented features of imperative languages.\n",
            "paragraph48": "Lisp (1958) stands for \"LISt Processor.\" It is tailored to process lists. A full structure of the data is formed by building lists of lists. In memory, a tree data structure is built. Internally, the tree structure lends nicely for recursive functions. The syntax to build a tree is to enclose the space-separated elements within parenthesis. The following is a list of three elements. The first two elements are themselves lists of two elements:\n",
            "paragraph49": "((A B) (HELLO WORLD) 94)\n",
            "paragraph50": "Lisp has functions to extract and reconstruct elements. The function head() returns a list containing the first element in the list. The function tail() returns a list containing everything but the first element. The function cons() returns a list that is the concatenation of other lists. Therefore, the following expression will return the list x:\n",
            "paragraph51": "cons(head(x), tail(x))\n",
            "paragraph52": "One drawback of Lisp is when many functions are nested, the parentheses may look confusing. Modern Lisp environments help ensure parenthesis match. As an aside, Lisp does support the imperative language operations of the assignment statement and goto loops. Also, Lisp is not concerned with the datatype of the elements at compile time. Instead, it assigns the datatypes at runtime. This may lead to programming errors not being detected early in the development process.\n",
            "paragraph53": "Writing large, reliable, and readable Lisp programs requires forethought. If properly planned, the program may be much shorter than an equivalent imperative language program. Lisp is widely used in artificial intelligence. However, its usage has been accepted only because it has imperative language operations, making unintended side-effects possible.\n",
            "paragraph54": "ML (1973) stands for \"Meta Language.\" ML checks to make sure only data of the same type are compared with one another. For example, this function has one input parameter (an integer) and returns an integer:\n",
            "paragraph55": "fun times_10(n : int) : int = 10 * n;\n",
            "paragraph56": "ML is not parenthesis-eccentric like Lisp. The following is an application of times_10():\n",
            "paragraph57": "times_10 2\n",
            "paragraph58": "It returns \"20 : int\". (Both the results and the datatype are returned.)\n",
            "paragraph59": "Like Lisp, ML is tailored to process lists. Unlike Lisp, each element is the same datatype.\n",
            "paragraph60": "Prolog (1972) stands for \"PROgramming in LOgic.\" It was designed to process natural languages. The building blocks of a Prolog program are objects and their relationships to other objects. Objects are built by stating true facts about them.\n",
            "paragraph61": "Set theory facts are formed by assigning objects to sets. The syntax is setName(object).\n",
            "ul17": "Cat is an animal.\n",
            "ul18": "Mouse is an animal.\n",
            "ul19": "Tom is a cat.\n",
            "ul20": "Jerry is a mouse.\n",
            "paragraph62": "Adjective facts are formed using adjective(object).\n",
            "ul21": "Cat is big.\n",
            "ul22": "Mouse is small.\n",
            "paragraph63": "Relationships are formed using multiple items inside the parentheses. In our example we have verb(object,object) and verb(adjective,adjective).\n",
            "ul23": "Mouse eats cheese.\n",
            "ul24": "Big animals eat small animals.\n",
            "paragraph64": "After all the facts and relationships are entered, then a question can be asked:\n",
            "paragraph65": "Prolog's usage has expanded to become a goal-oriented language. In a goal-oriented application, the goal is defined by providing a list of subgoals. Then each subgoal is defined by further providing a list of its subgoals, etc. If a path of subgoals fails to find a solution, then that subgoal is backtracked and another path is systematically attempted. Practical applications include solving the shortest path problem and producing family trees.\n"
        },
        {
            "title": "Program modules",
            "paragraph1": "Modular programming is a technique to refine imperative language programs. A program module is a sequence of statements that are bounded within a block and together identified by a name. Modules have a function, context, and logic:\n",
            "ul1": "The function of a module is what it does.\nThe context of a module are the elements being performed upon.\nThe logic of a module is how it performs the function.\n",
            "paragraph2": "The module's name should be derived first by its function, then by its context. Its logic should not be part of the name. For example, function compute_square_root( x ) or function compute_square_root_integer( i : integer ) are appropriate module names. However, function compute_square_root_by_division( x ) is not.\n",
            "paragraph3": "The degree of interaction within a module is its level of cohesion. Cohesion is a judgement of the relationship between a module's name and its function. The degree of interaction between modules is the level of coupling. Coupling is a judgement of the relationship between a module's context and the elements being performed upon.\n",
            "subtitle1": "Cohesion",
            "paragraph4": "The levels of cohesion from worst to best are:\n",
            "ul2": "Coincidental Cohesion: A module has coincidental cohesion if it performs multiple functions, and the functions are completely unrelated. For example, function read_sales_record_print_next_line_convert_to_float(). Coincidental cohesion occurs in practice if management enforces silly rules. For example, \"Every module will have between 35 and 50 executable statements.\"[85]\nLogical Cohesion: A module has logical cohesion if it has available a series of functions, but only one of them is executed. For example, function perform_arithmetic( perform_addition ).\nTemporal Cohesion: A module has temporal cohesion if it performs functions related to time. One example, function initialize_variables_and_open_files(). Another example, stage_one(), stage_two(), ...\nProcedural Cohesion: A module has procedural cohesion if it performs multiple functions, but only loosely related. For example, function read_part_number_update_employee_record().\nCommunicational Cohesion: A module has communicational cohesion if it performs multiple functions, but closely related. For example, function read_part_number_update_sales_record().\nInformational Cohesion: A module has informational cohesion if it performs multiple functions, but each function has its own entry and exit points. Moreover, the functions share the same data structure. Object-oriented classes work at this level.\nFunctional Cohesion: a module has functional cohesion if it achieves a single goal working only on local variables. Moreover, it may be reusable in other contexts.\n",
            "subtitle2": "Coupling",
            "paragraph5": "The levels of coupling from worst to best are:\n",
            "ul3": "Content Coupling: A module has content coupling if it modifies a local variable of another function. COBOL used to do this with the alter verb.\nCommon Coupling: A module has common coupling if it modifies a global variable.\nControl Coupling: A module has control coupling if another module can modify its control flow. For example, perform_arithmetic( perform_addition ). Instead, control should be on the makeup of the returned object.\nStamp Coupling: A module has stamp coupling if an element of a data structure passed as a parameter is modified. Object-oriented classes work at this level.\n Data Coupling: A module has data coupling if all of its input parameters are needed and none of them are modified. Moreover, the result of the function is returned as a single object.\n",
            "subtitle3": "Data flow analysis",
            "image1": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/5/58/Sandwich_data_flow_diagram.pdf/page1-440px-Sandwich_data_flow_diagram.pdf.jpg",
                "caption": "\n\t\tA sample function-level data-flow diagram.\n\t"
            },
            "paragraph6": "Data flow analysis is a design method used to achieve modules of functional cohesion and data coupling. The input to the method is a data-flow diagram. A data-flow diagram is a set of ovals representing modules. Each module's name is displayed inside its oval. Modules may be at the executable level or the function level.\n",
            "paragraph7": "The diagram also has arrows connecting modules to each other. Arrows pointing into modules represent a set of inputs. Each module should have only one arrow pointing out from it to represent its single output object. (Optionally, an additional exception arrow points out.) A daisy chain of ovals will convey an entire algorithm. The input modules should start the diagram. The input modules should connect to the transform modules. The transform modules should connect to the output modules.\n",
            "subtitle4": "Object-oriented programming",
            "paragraph8": "Object-oriented programming need not be confined to an object-oriented language. Object-oriented programming is executing operations on objects. In object-oriented languages, classes are objects. In non-object-oriented languages, data structures (which are also known as records) may also be objects. To turn a data structure into an object, operations need to be written specifically for the structure. The resulting structure is called an abstract datatype. However, inheritance will be missing. Nonetheless, this shortcoming can be overcome.\n",
            "paragraph9": "Here is a C programming language header file for the GRADE abstract datatype in a simple school application:\n",
            "paragraph10": "The grade_new() function performs the same algorithm as the C++ constructor operation.\n",
            "paragraph11": "Here is a C programming language source file for the GRADE abstract datatype in a simple school application:\n",
            "paragraph12": "In the constructor, the function calloc() is used instead of malloc() because each memory cell will be set to zero.\n",
            "paragraph13": "Here is a C programming language header file for the PERSON abstract datatype in a simple school application:\n",
            "paragraph14": "Here is a C programming language source code for the PERSON abstract datatype in a simple school application:\n",
            "paragraph15": "Here is a C programming language header file for the STUDENT abstract datatype in a simple school application:\n",
            "paragraph16": "Here is a C programming language source code for the STUDENT abstract datatype in a simple school application:\n",
            "paragraph17": "Here is a driver program for demonstration:\n",
            "paragraph18": "Here is a makefile to compile everything:\n",
            "paragraph19": "The formal strategy to build object-oriented objects is to:\n",
            "ul4": "Identify the objects. Most likely these will be nouns.\nIdentify each object's attributes. What helps to describe the object?\nIdentify each object's actions. Most likely these will be verbs.\nIdentify the relationships from object to object. Most likely these will be verbs.\n",
            "paragraph20": "For example:\n",
            "ul5": "A person is a human identified by a name.\nA grade is an achievement identified by a letter.\nA student is a person who earns a grade.\n"
        },
        {
            "title": "Functional categories",
            "image1": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/8/87/Operating_system_placement_%28software%29.svg/340px-Operating_system_placement_%28software%29.svg.png",
                "caption": "\n\t\tA diagram showing that the user interacts with the application software. The application software interacts with the operating system, which interacts with the hardware.\n\t"
            },
            "paragraph1": "Computer programs may be categorized along functional lines. The main functional categories are application software and system software. System software includes the operating system which couples computer hardware with application software. The purpose of the operating system is to provide an environment where application software executes in a convenient and efficient manner. In addition to the operating system, system software includes embedded programs, boot programs, and micro programs. Application software designed for end users have a user interface. Application software not designed for end users includes middleware, which couples one application with another. Both system software and application software execute utility programs.\n",
            "subtitle1": "Application software",
            "paragraph2": "Application software is the key to unlocking the potential of the computer system. Enterprise application software bundles accounting, personnel, customer, and vendor applications. Examples include enterprise resource planning, customer relationship management, and supply chain management software. \n",
            "paragraph3": "Enterprise applications may be developed in-house as a one-of-a-kind proprietary software. Alternatively, they may be purchased as off-the-shelf software. Purchased software may be modified to provide custom software. If the application is customized, then either the company's resources are used or the resources are outsourced. Outsourced software development may be from the original software vendor or a third-party developer.\n",
            "paragraph4": "The advantages of proprietary software are features and reports may be exact to specification. Management may also be involved in the development process and offer a level of control. Management may decide to counteract a competitor's new initiative or implement a customer or vendor requirement. A merger or acquisition will necessitate enterprise software changes. The disadvantages of proprietary software are the time and resource costs may be extensive. Furthermore, risks concerning features and performance may be looming.\n",
            "paragraph5": "The advantages of off-the-shelf software are its identifiable upfront costs, the basic needs should be fulfilled, and its performance and reliability have a track record. The disadvantages of off-the-shelf software are it may have unnecessary features that  confuse end users, it may lack features the enterprise needs, and the data flow may not match the enterprise's work processes.\n",
            "paragraph6": "One approach to economically obtaining a customized enterprise application is through an application service provider. Specialty companies provide the hardware, custom software, and end-user support. They may speed development of new applications because they possess skilled information system staff. The biggest advantage is it frees in-house resources from staffing and managing complex computer projects. Many application service providers target small, fast-growing companies with limited information system resources. On the other hand, larger companies with major systems will likely have their technical infrastructure in place. One risk is having to trust an external organization with sensitive information. Another risk is having to trust the provider's infrastructure reliability.\n",
            "subtitle2": "Operating system",
            "paragraph7": "An operating system is the low-level software that supports a computer's basic functions, such as scheduling tasks and controlling peripherals.\n",
            "paragraph8": "In the 1950s, the programmer, who was also the operator, would write a program and run it. After the program finished executing, the output may have been printed, or it may have been punched onto paper tape or cards for later processing. More often than not the program did not work. The programmer then looked at the console lights and fiddled with the console switches. If less fortunate, a memory printout was made for further study. In the 1960s, programmers reduced the amount of wasted time by automating the operator's job. A program called an operating system was kept in the computer at all times.\n",
            "paragraph9": "The term operating system may refer to two levels of software. The operating system may refer to the kernel program that manages the processes, memory, and devices. More broadly, the operating system may refer to the entire package of the central software. The package includes a kernel program, command-line interpreter, graphical user interface, utility programs, and editor.\n",
            "image2": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Kernel_Layout.svg/440px-Kernel_Layout.svg.png",
                "caption": "\n\t\tA kernel connects the application software to the hardware of a computer.\n\t"
            },
            "paragraph10": "The kernel's main purpose is to manage the limited resources of a computer:\n",
            "ul1": "The kernel program should perform process scheduling.[97] The kernel creates a process control block when a program is selected for execution. However, an executing program gets exclusive access to the central processing unit only for a time slice. To provide each user with the illusion of exclusive access, the kernel preempts the process control block to execute another one. The goal for system developers is to minimize dispatch latency.\n",
            "image3": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Virtual_memory.svg/500px-Virtual_memory.svg.png",
                "caption": "\n\t\tPhysical memory is scattered around RAM and the hard disk. Virtual memory is one continuous block.\n\t"
            },
            "ul2": "The kernel program should perform memory management.\n",
            "ul3": "The kernel program should perform file system management.[97] The kernel has instructions to create, retrieve, update, and delete files.\nThe kernel program should perform device management.[97] The kernel provides programs to standardize and simplify the interface to the mouse, keyboard, disk drives, printers, and other devices. Moreover, the kernel should arbitrate access to a device if two processes requests it at the same time.\nThe kernel program should perform network management.[102] The kernel transmits and receives packets on behalf of processes. One key service is to find an efficient route to the target system.\nThe kernel program should provide system level functions for programmers to use.[103]\nProgrammers access files through a relatively simple interface that in turn executes a relatively complicated low-level I/O interface. The low-level interface includes file creation, file descriptors, file seeking, physical reading, and physical writing.\nProgrammers create processes through a relatively simple interface that in turn executes a relatively complicated low-level interface.\nProgrammers perform date/time arithmetic through a relatively simple interface that in turn executes a relatively complicated low-level time interface.[104]\nProgrammers access files through a relatively simple interface that in turn executes a relatively complicated low-level I/O interface. The low-level interface includes file creation, file descriptors, file seeking, physical reading, and physical writing.\nProgrammers create processes through a relatively simple interface that in turn executes a relatively complicated low-level interface.\nProgrammers perform date/time arithmetic through a relatively simple interface that in turn executes a relatively complicated low-level time interface.[104]\nThe kernel program should provide a communication channel between executing processes.[105] For a large software system, it may be desirable to engineer the system into smaller processes. Processes may communicate with one another by sending and receiving signals.\n",
            "paragraph11": "Originally, operating systems were programmed in assembly; however, modern operating systems are typically written in higher level languages like C, C++, Objective-C, and Swift.\n",
            "paragraph12": "Interrupts cause the central processing unit (CPU) to have a control flow change away from the currently running process. Input/Output (I/O) devices are slower than the CPU's clock signal. Therefore, it would slow down the computer if the CPU had to wait for each I/O to finish. Instead, a computer may implement direct memory access (DMA) I/O.\n",
            "paragraph13": "If a computer program executes a system call to perform a DMA I/O write operation, then the system call may execute the following instructions:\n",
            "ul4": "Set the contents of the CPU's registers (including the program counter) into the process control block.[108]\nCreate an entry in the device-status table.[109] The operating system maintains this table to keep track of which processes are waiting for which devices. One field in the table is the address of the process control block.\nPlace all the characters to be sent to the device into a memory buffer.[106]\nSet the memory address of the memory buffer to a predetermined device register.[110]\nSet the buffer size (an integer) to another predetermined register.[110]\nExecute the machine instruction to begin the writing.\nPerform a context switch to the next process in the ready queue.\n",
            "paragraph14": "While the writing takes place, the operating system will context switch to other processes as normal. When the device finishes writing, the device will interrupt the currently running process by asserting an interrupt request. The device will also place an integer onto the device's data bus. Upon accepting the interrupt request, the CPU will:\n",
            "ul5": "Push the contents of its program counter and program status word onto the call stack.[112]\nRead the integer from the data bus. The integer is an offset to the interrupt vector table. The vector table's instructions will return control to the operating system.\n",
            "paragraph15": "The operating system will then:\n",
            "ul6": "Access the device-status table.\nExtract the process control block.\nPerform a context switch back to the writing process.\n",
            "paragraph16": "When the writing process has its time slice expired, the CPU will:\n",
            "ul7": "Pop from the call stack the program status word and set it back to its register.\nPop from the call stack the address of the interrupted process' next instruction and set it back into the program counter.\n",
            "paragraph17": "The interrupted process will then resume its time slice.\n",
            "subtitle3": "Utility program",
            "paragraph18": "A utility program is designed to aid system administration and software execution. Operating systems execute hardware utility programs to check the status of disk drives, memory, speakers, and printers. A utility program may optimize the placement of a file on a crowded disk. System utility programs monitor hardware and network performance. When a metric is outside an acceptable range, a trigger alert is generated.\n",
            "paragraph19": "Utility programs include compression programs so data files are stored on less disk space. Compressed programs also save time when data files are transmitted over the network. Utility programs can sort and merge data sets. Utility programs detect computer viruses.\n",
            "subtitle4": "Boot program",
            "paragraph20": "A stored-program computer requires an initial boot program stored in its read-only memory to boot. It should identify and initialize all aspects of the system, from processor registers to device controllers to memory contents. Following the initialization process, the boot program loads the operating system and sets the program counter to begin normal operations.\n",
            "subtitle5": "Embedded program",
            "image6": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/USB_flash_drive.JPG/392px-USB_flash_drive.JPG",
                "caption": "\n\t\tThe microcontroller on the right of this USB flash drive is controlled with embedded firmware.\n\t"
            },
            "paragraph21": "Independent of the host computer, a hardware device might have embedded firmware to control its operation. Firmware is used when the computer program is rarely or never expected to change, or when it must not be lost when the power is off.\n",
            "paragraph22": "On a larger scale, an embedded microcontroller is used to control part of a larger system. Examples include aircraft components and life support systems. Applications running on these systems are large and complex. Moreover, they run in real-time and must be robust. The United States Department of Defense contracted with CII Honeywell Bull to develop Ada (1983) as a real-time programming language.\n",
            "paragraph23": "Central to real-time systems is a task facility to permit parallel processing. Also important are interrupt controls.\n",
            "subtitle6": "Microcode program",
            "image7": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Not-gate-en.svg/192px-Not-gate-en.svg.png",
                "caption": "\n\t\tNOT gate.\n\t"
            },
            "image8": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/e/e6/NAND_ANSI_Labelled.svg/192px-NAND_ANSI_Labelled.svg.png",
                "caption": "\n\t\tNAND gate.\n\t"
            },
            "image9": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/c/c6/NOR_ANSI_Labelled.svg/192px-NOR_ANSI_Labelled.svg.png",
                "caption": "\n\t\tNOR gate.\n\t"
            },
            "image10": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/b/b9/AND_ANSI_Labelled.svg/192px-AND_ANSI_Labelled.svg.png",
                "caption": "\n\t\tAND gate.\n\t"
            },
            "image11": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/1/16/OR_ANSI_Labelled.svg/192px-OR_ANSI_Labelled.svg.png",
                "caption": "\n\t\tOR gate.\n\t"
            },
            "paragraph24": "A microcode program is the bottom-level interpreter that controls the data path of software driven computers.\n(Advances in hardware have migrated these operations to hardware execution circuits.) Microcode instructions allow the programmer to more easily implement the digital logic level—the computer's real hardware. The digital logic level is the boundary between computer science and computer engineering.\n",
            "paragraph25": "A gate is a tiny transistor that can return one of two signals: on or off.\n",
            "ul8": "Having one transistor forms the NOT gate.\nConnecting two transistors in series forms the NAND gate.\nConnecting two transistors in parallel forms the NOR gate.\nConnecting a NOT gate to a NAND gate forms the AND gate.\nConnecting a NOT gate to a NOR gate forms the OR gate.\n",
            "paragraph26": "These five gates form the building blocks of binary algebra—the digital logic functions of the computer.\n",
            "paragraph27": "Microcode instructions are mnemonics programmers may use to execute digital logic functions instead of forming them in binary algebra. They are stored in a central processing unit's (CPU) control store.\nThese hardware-level instructions move data throughout the data path.\n",
            "paragraph28": "Microcode instructions move data between a CPU's registers and throughout the motherboard. The micro-instruction cycle begins when the microsequencer uses its microprogram counter to fetch the next machine instruction from random access memory. The next step is to decode the machine instruction by selecting the proper output line to the hardware module.\nThe final step is to execute the instruction using the hardware module's set of gates.\n",
            "image12": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/0/0f/ALU_block.gif/440px-ALU_block.gif",
                "caption": "\n\t\tA symbolic representation of an ALU.\n\t"
            },
            "paragraph29": "Instructions to perform arithmetic are passed through an arithmetic logic unit (ALU). The ALU has circuits to perform elementary operations to add, shift, and compare integers. By combining and looping the elementary operations through the ALU, the CPU performs its complex arithmetic.\n",
            "paragraph30": "Microcode instructions move data between the CPU and the memory controller. Memory controller microcode instructions manipulate two registers. The memory address register is used to access each memory cell's address. The memory data register is used to set and read each cell's contents.\n",
            "paragraph31": "Microcode instructions move data between the CPU and the many computer buses. The disk controller bus writes to and reads from hard disk drives. Data is also moved between the CPU and other functional units via the peripheral component interconnect express bus.\n"
        }
    ],
    "links": [
        "https://en.wikipedia.org/wiki/The_Computer_Programme",
        "https://en.wikipedia.org/wiki/Computer_code",
        "https://en.wikipedia.org/wiki/Compiler",
        "https://en.wikipedia.org/wiki/Optimizing_compiler",
        "https://en.wikipedia.org/wiki/Intermediate_representation",
        "https://en.wikipedia.org/wiki/Runtime_system",
        "https://en.wikipedia.org/wiki/Executable",
        "https://en.wikipedia.org/wiki/Virtual_machine",
        "https://en.wikipedia.org/wiki/Source_code",
        "https://en.wikipedia.org/wiki/Object_code",
        "https://en.wikipedia.org/wiki/Bytecode",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Microcode",
        "https://en.wikipedia.org/wiki/Dynamic_recompilation",
        "https://en.wikipedia.org/wiki/Android_Runtime",
        "https://en.wikipedia.org/wiki/Common_Language_Runtime",
        "https://en.wikipedia.org/wiki/Crt0",
        "https://en.wikipedia.org/wiki/Java_virtual_machine",
        "https://en.wikipedia.org/wiki/CPython",
        "https://en.wikipedia.org/wiki/PyPy",
        "https://en.wikipedia.org/wiki/Zend_Engine",
        "https://en.wikipedia.org/wiki/GNU_Compiler_Collection",
        "https://en.wikipedia.org/wiki/LLVM",
        "https://en.wikipedia.org/wiki/Clang",
        "https://en.wikipedia.org/wiki/Imperative_programming",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Computer",
        "https://en.wikipedia.org/wiki/Declarative_programming",
        "https://en.wikipedia.org/wiki/Source_code",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Compiler",
        "https://en.wikipedia.org/wiki/Machine_language",
        "https://en.wikipedia.org/wiki/Executable",
        "https://en.wikipedia.org/wiki/Java_bytecode",
        "https://en.wikipedia.org/wiki/Java_virtual_machine",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Central_processing_unit",
        "https://en.wikipedia.org/wiki/Context_switch",
        "https://en.wikipedia.org/wiki/Instruction_cycle",
        "https://en.wikipedia.org/wiki/History_of_computing",
        "https://en.wikipedia.org/wiki/History_of_programming_languages",
        "https://en.wikipedia.org/wiki/History_of_software",
        "https://en.wikipedia.org/wiki/Charles_Babbage",
        "https://en.wikipedia.org/wiki/Jacquard_machine",
        "https://en.wikipedia.org/wiki/Analytical_Engine",
        "https://en.wikipedia.org/wiki/Ada_Lovelace",
        "https://en.wikipedia.org/wiki/Luigi_Menabrea",
        "https://en.wikipedia.org/wiki/Bernoulli_number",
        "https://en.wikipedia.org/wiki/Alan_Turing",
        "https://en.wikipedia.org/wiki/Universal_Turing_machine",
        "https://en.wikipedia.org/wiki/Turing_complete",
        "https://en.wikipedia.org/wiki/Algorithm",
        "https://en.wikipedia.org/wiki/Konrad_Zuse",
        "https://en.wikipedia.org/wiki/Germany",
        "https://en.wikipedia.org/wiki/Binary_code",
        "https://en.wikipedia.org/wiki/Relay",
        "https://en.wikipedia.org/wiki/Punched_tape",
        "https://en.wikipedia.org/wiki/ETH_Zurich",
        "https://en.wikipedia.org/wiki/Harvard_Mark_I",
        "https://en.wikipedia.org/wiki/IBM",
        "https://en.wikipedia.org/wiki/Trigonometry",
        "https://en.wikipedia.org/wiki/Interpolation",
        "https://en.wikipedia.org/wiki/Logarithm",
        "https://en.wikipedia.org/wiki/Punched_tape",
        "https://en.wikipedia.org/wiki/Harvard_Mark_II",
        "https://en.wikipedia.org/wiki/IBM_SSEC",
        "https://en.wikipedia.org/wiki/ENIAC",
        "https://en.wikipedia.org/wiki/Turing_complete",
        "https://en.wikipedia.org/wiki/Vacuum_tube",
        "https://en.wikipedia.org/wiki/Electronic_circuit",
        "https://en.wikipedia.org/wiki/Pascaline",
        "https://en.wikipedia.org/wiki/Inflation",
        "https://en.wikipedia.org/wiki/Aberdeen_Proving_Ground",
        "https://en.wikipedia.org/wiki/John_Mauchly",
        "https://en.wikipedia.org/wiki/John_von_Neumann",
        "https://en.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC",
        "https://en.wikipedia.org/wiki/Von_Neumann_architecture",
        "https://en.wikipedia.org/wiki/EDVAC",
        "https://en.wikipedia.org/wiki/EDSAC",
        "https://en.wikipedia.org/wiki/ALGOL_60",
        "https://en.wikipedia.org/wiki/Compiler",
        "https://en.wikipedia.org/wiki/Instruction_set",
        "https://en.wikipedia.org/wiki/Application_software",
        "https://en.wikipedia.org/wiki/COBOL",
        "https://en.wikipedia.org/wiki/Fortran",
        "https://en.wikipedia.org/wiki/ALGOL",
        "https://en.wikipedia.org/wiki/Compiler",
        "https://en.wikipedia.org/wiki/Data_General_Nova",
        "https://en.wikipedia.org/wiki/Paper_tape",
        "https://en.wikipedia.org/wiki/Punched_cards",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Computer_programming",
        "https://en.wikipedia.org/wiki/Software_development",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Source_code",
        "https://en.wikipedia.org/wiki/Systems_analyst",
        "https://en.wikipedia.org/wiki/Functional_requirement",
        "https://en.wikipedia.org/wiki/Computer_programmer",
        "https://en.wikipedia.org/wiki/Brian_Kernighan",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Reserved_word",
        "https://en.wikipedia.org/wiki/Control_flow",
        "https://en.wikipedia.org/wiki/Delimiter",
        "https://en.wikipedia.org/wiki/Formal_language",
        "https://en.wikipedia.org/wiki/Algorithm",
        "https://en.wikipedia.org/wiki/EDSAC",
        "https://en.wikipedia.org/wiki/Von_Neumann_architecture",
        "https://en.wikipedia.org/wiki/Programming_language_generations",
        "https://en.wikipedia.org/wiki/Machine_language",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Assembly_language",
        "https://en.wikipedia.org/wiki/Integer",
        "https://en.wikipedia.org/wiki/Processor_register",
        "https://en.wikipedia.org/wiki/Memory_address",
        "https://en.wikipedia.org/wiki/Compiler",
        "https://en.wikipedia.org/wiki/Fortran",
        "https://en.wikipedia.org/wiki/COBOL",
        "https://en.wikipedia.org/wiki/ALGOL",
        "https://en.wikipedia.org/wiki/BASIC",
        "https://en.wikipedia.org/wiki/Programming_paradigm",
        "https://en.wikipedia.org/wiki/Imperative_programming",
        "https://en.wikipedia.org/wiki/Declarative_programming",
        "https://en.wikipedia.org/wiki/SQL",
        "https://en.wikipedia.org/wiki/Database",
        "https://en.wikipedia.org/wiki/Integrated_development_environment",
        "https://en.wikipedia.org/wiki/Graphical_user_interface",
        "https://en.wikipedia.org/wiki/Computer_mouse",
        "https://en.wikipedia.org/wiki/Datatype",
        "https://en.wikipedia.org/wiki/Control_flow",
        "https://en.wikipedia.org/wiki/FORTRAN",
        "https://en.wikipedia.org/wiki/Array_data_structure",
        "https://en.wikipedia.org/wiki/Subroutine",
        "https://en.wikipedia.org/wiki/For_loop",
        "https://en.wikipedia.org/wiki/American_National_Standards_Institute",
        "https://en.wikipedia.org/wiki/COBOL",
        "https://en.wikipedia.org/wiki/US_Department_of_Defense",
        "https://en.wikipedia.org/wiki/Grace_Hopper",
        "https://en.wikipedia.org/wiki/ALGOL",
        "https://en.wikipedia.org/wiki/For_loop",
        "https://en.wikipedia.org/wiki/BASIC",
        "https://en.wikipedia.org/wiki/Dartmouth_College",
        "https://en.wikipedia.org/wiki/Microcomputers",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Microsoft",
        "https://en.wikipedia.org/wiki/Visual_Basic",
        "https://en.wikipedia.org/wiki/Graphical_user_interface",
        "https://en.wikipedia.org/wiki/BCPL",
        "https://en.wikipedia.org/wiki/Bell_Labs",
        "https://en.wikipedia.org/wiki/UNIX",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Assembly_language",
        "https://en.wikipedia.org/wiki/Inline_assembler",
        "https://en.wikipedia.org/wiki/Clock_signal",
        "https://en.wikipedia.org/wiki/C_dynamic_memory_allocation",
        "https://en.wikipedia.org/wiki/Data_segment",
        "https://en.wikipedia.org/wiki/Memory_address",
        "https://en.wikipedia.org/wiki/Processor_register",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Out_of_memory",
        "https://en.wikipedia.org/wiki/C_dynamic_memory_allocation",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Modular_programming",
        "https://en.wikipedia.org/wiki/Computer_file",
        "https://en.wikipedia.org/wiki/Abstract_and_concrete",
        "https://en.wikipedia.org/wiki/Data_type",
        "https://en.wikipedia.org/wiki/Integer",
        "https://en.wikipedia.org/wiki/Functional_programming",
        "https://en.wikipedia.org/wiki/Subset",
        "https://en.wikipedia.org/wiki/Set_theory",
        "https://en.wikipedia.org/wiki/Simula",
        "https://en.wikipedia.org/wiki/Include_directive",
        "https://en.wikipedia.org/wiki/Makefile",
        "https://en.wikipedia.org/wiki/Declarative_programming",
        "https://en.wikipedia.org/wiki/Functional_language",
        "https://en.wikipedia.org/wiki/Logic_programming",
        "https://en.wikipedia.org/wiki/Lambda_calculus",
        "https://en.wikipedia.org/wiki/Call_stack",
        "https://en.wikipedia.org/wiki/Program_counter",
        "https://en.wikipedia.org/wiki/Computer_science",
        "https://en.wikipedia.org/wiki/Parallel_computing",
        "https://en.wikipedia.org/wiki/Concurrent_computing",
        "https://en.wikipedia.org/wiki/Integrated_development_environment",
        "https://en.wikipedia.org/wiki/Data_type",
        "https://en.wikipedia.org/wiki/Artificial_intelligence",
        "https://en.wikipedia.org/wiki/Prolog",
        "https://en.wikipedia.org/wiki/Natural_language",
        "https://en.wikipedia.org/wiki/Adjective",
        "https://en.wikipedia.org/wiki/Backtracking",
        "https://en.wikipedia.org/wiki/Shortest_path_problem",
        "https://en.wikipedia.org/wiki/Family_tree",
        "https://en.wikipedia.org/wiki/Modular_programming",
        "https://en.wikipedia.org/wiki/Control_flow",
        "https://en.wikipedia.org/wiki/Algorithm",
        "https://en.wikipedia.org/wiki/Data_structure",
        "https://en.wikipedia.org/wiki/C_programming_language",
        "https://en.wikipedia.org/wiki/Makefile",
        "https://en.wikipedia.org/wiki/Application_software",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Personal_computer_hardware",
        "https://en.wikipedia.org/wiki/Application_software",
        "https://en.wikipedia.org/wiki/System_software",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Computer_hardware",
        "https://en.wikipedia.org/wiki/Firmware",
        "https://en.wikipedia.org/wiki/Booting",
        "https://en.wikipedia.org/wiki/Microcode",
        "https://en.wikipedia.org/wiki/End_user",
        "https://en.wikipedia.org/wiki/Middleware",
        "https://en.wikipedia.org/wiki/Utility_software",
        "https://en.wikipedia.org/wiki/Application_software",
        "https://en.wikipedia.org/wiki/Enterprise_software",
        "https://en.wikipedia.org/wiki/Enterprise_resource_planning",
        "https://en.wikipedia.org/wiki/Customer_relationship_management",
        "https://en.wikipedia.org/wiki/Supply_chain_management_software",
        "https://en.wikipedia.org/wiki/Proprietary_software",
        "https://en.wikipedia.org/wiki/Custom_software",
        "https://en.wikipedia.org/wiki/Application_service_provider",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Peripheral",
        "https://en.wikipedia.org/wiki/Computer_memory",
        "https://en.wikipedia.org/wiki/Peripheral",
        "https://en.wikipedia.org/wiki/Graphical_user_interface",
        "https://en.wikipedia.org/wiki/Utility_software",
        "https://en.wikipedia.org/wiki/Process_control_block",
        "https://en.wikipedia.org/wiki/Central_processing_unit",
        "https://en.wikipedia.org/wiki/Systems_programming",
        "https://en.wikipedia.org/wiki/Dispatch_latency",
        "https://en.wikipedia.org/wiki/Memory_management",
        "https://en.wikipedia.org/wiki/Virtual_address_space",
        "https://en.wikipedia.org/wiki/Physical_address",
        "https://en.wikipedia.org/wiki/Memory_controller",
        "https://en.wikipedia.org/wiki/Page_fault",
        "https://en.wikipedia.org/wiki/Memory_management_unit",
        "https://en.wikipedia.org/wiki/Manual_memory_management",
        "https://en.wikipedia.org/wiki/File_system",
        "https://en.wikipedia.org/wiki/Peripheral",
        "https://en.wikipedia.org/wiki/Network_management",
        "https://en.wikipedia.org/wiki/Network_packet",
        "https://en.wikipedia.org/wiki/Routing_table",
        "https://en.wikipedia.org/wiki/System_calls",
        "https://en.wikipedia.org/wiki/File_descriptor",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Assembly_language",
        "https://en.wikipedia.org/wiki/Interrupt",
        "https://en.wikipedia.org/wiki/Central_processing_unit",
        "https://en.wikipedia.org/wiki/Control_flow",
        "https://en.wikipedia.org/wiki/Peripheral",
        "https://en.wikipedia.org/wiki/Clock_signal",
        "https://en.wikipedia.org/wiki/System_call",
        "https://en.wikipedia.org/wiki/Program_counter",
        "https://en.wikipedia.org/wiki/Process_control_block",
        "https://en.wikipedia.org/wiki/Random_access_memory",
        "https://en.wikipedia.org/wiki/Memory_address",
        "https://en.wikipedia.org/wiki/Device_register",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Context_switch",
        "https://en.wikipedia.org/wiki/Multilevel_feedback_queue",
        "https://en.wikipedia.org/wiki/Program_status_word",
        "https://en.wikipedia.org/wiki/Call_stack",
        "https://en.wikipedia.org/wiki/Interrupt_vector_table",
        "https://en.wikipedia.org/wiki/Utility_software",
        "https://en.wikipedia.org/wiki/Computer_virus",
        "https://en.wikipedia.org/wiki/Booting",
        "https://en.wikipedia.org/wiki/Processor_register",
        "https://en.wikipedia.org/wiki/Device_driver",
        "https://en.wikipedia.org/wiki/Volatile_memory",
        "https://en.wikipedia.org/wiki/Operating_system",
        "https://en.wikipedia.org/wiki/Program_counter",
        "https://en.wikipedia.org/wiki/Embedded_software",
        "https://en.wikipedia.org/wiki/Microcontroller",
        "https://en.wikipedia.org/wiki/USB_flash_drive",
        "https://en.wikipedia.org/wiki/Firmware",
        "https://en.wikipedia.org/wiki/Peripheral",
        "https://en.wikipedia.org/wiki/Firmware",
        "https://en.wikipedia.org/wiki/Microcontroller",
        "https://en.wikipedia.org/wiki/United_States_Department_of_Defense",
        "https://en.wikipedia.org/wiki/Groupe_Bull",
        "https://en.wikipedia.org/wiki/Parallel_computing",
        "https://en.wikipedia.org/wiki/Interrupt",
        "https://en.wikipedia.org/wiki/Microcode",
        "https://en.wikipedia.org/wiki/Microcode",
        "https://en.wikipedia.org/wiki/Datapath",
        "https://en.wikipedia.org/wiki/Logic_level",
        "https://en.wikipedia.org/wiki/Computer_science",
        "https://en.wikipedia.org/wiki/Computer_engineering",
        "https://en.wikipedia.org/wiki/Transistor",
        "https://en.wikipedia.org/wiki/NAND_gate",
        "https://en.wikipedia.org/wiki/NOR_gate",
        "https://en.wikipedia.org/wiki/AND_gate",
        "https://en.wikipedia.org/wiki/OR_gate",
        "https://en.wikipedia.org/wiki/Boolean_algebra",
        "https://en.wikipedia.org/wiki/Central_processing_unit",
        "https://en.wikipedia.org/wiki/Control_store",
        "https://en.wikipedia.org/wiki/Datapath",
        "https://en.wikipedia.org/wiki/Processor_register",
        "https://en.wikipedia.org/wiki/Motherboard",
        "https://en.wikipedia.org/wiki/Microsequencer",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Random_access_memory",
        "https://en.wikipedia.org/wiki/Arithmetic_logic_unit",
        "https://en.wikipedia.org/wiki/Memory_controller",
        "https://en.wikipedia.org/wiki/Processor_register",
        "https://en.wikipedia.org/wiki/Memory_address_register",
        "https://en.wikipedia.org/wiki/Memory_buffer_register",
        "https://en.wikipedia.org/wiki/Disk_controller",
        "https://en.wikipedia.org/wiki/Hard_disk_drive",
        "https://en.wikipedia.org/wiki/PCI_Express",
        "https://en.wikipedia.org/wiki/ActionScript",
        "https://en.wikipedia.org/wiki/Adobe_Flash",
        "https://en.wikipedia.org/wiki/Agile_software_development",
        "https://en.wikipedia.org/wiki/Algorithmic_efficiency",
        "https://en.wikipedia.org/wiki/Analog_computer",
        "https://en.wikipedia.org/wiki/Application_programming_interface",
        "https://en.wikipedia.org/wiki/Array_data_type",
        "https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming",
        "https://en.wikipedia.org/wiki/Artificial_intelligence",
        "https://en.wikipedia.org/wiki/Association_for_Computing_Machinery",
        "https://en.wikipedia.org/wiki/Automatic_programming",
        "https://en.wikipedia.org/wiki/Automaton",
        "https://en.wikipedia.org/wiki/Banu_Musa",
        "https://en.wikipedia.org/wiki/Bernoulli_numbers",
        "https://en.wikipedia.org/wiki/Big_O_notation",
        "https://en.wikipedia.org/wiki/Bill_Gates",
        "https://en.wikipedia.org/wiki/Binary_number",
        "https://en.wikipedia.org/wiki/Binary_numeral_system",
        "https://en.wikipedia.org/wiki/Binary_tree",
        "https://en.wikipedia.org/wiki/Book_of_Ingenious_Devices",
        "https://en.wikipedia.org/wiki/Boot_loader",
        "https://en.wikipedia.org/wiki/Branch_instruction",
        "https://en.wikipedia.org/wiki/Breakpoint",
        "https://en.wikipedia.org/wiki/Buffer_overflow",
        "https://en.wikipedia.org/wiki/Build_automation",
        "https://en.wikipedia.org/wiki/Code_duplication",
        "https://en.wikipedia.org/wiki/Code_refactoring",
        "https://en.wikipedia.org/wiki/Command_line",
        "https://en.wikipedia.org/wiki/Commercial_software",
        "https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures",
        "https://en.wikipedia.org/wiki/Compiled",
        "https://en.wikipedia.org/wiki/Computation",
        "https://en.wikipedia.org/wiki/Computer_configuration",
        "https://en.wikipedia.org/wiki/Computer_network",
        "https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era",
        "https://en.wikipedia.org/wiki/Computer_storage",
        "https://en.wikipedia.org/wiki/Computer_system",
        "https://en.wikipedia.org/wiki/Computer_terminal",
        "https://en.wikipedia.org/wiki/ComputerWorld",
        "https://en.wikipedia.org/wiki/Cryptanalysis",
        "https://en.wikipedia.org/wiki/Cryptographic",
        "https://en.wikipedia.org/wiki/Data_storage_device",
        "https://en.wikipedia.org/wiki/David_Gries",
        "https://en.wikipedia.org/wiki/Debugger",
        "https://en.wikipedia.org/wiki/Debugging",
        "https://en.wikipedia.org/wiki/Desktop_applications",
        "https://en.wikipedia.org/wiki/Desktop_computer",
        "https://en.wikipedia.org/wiki/Documentation",
        "https://en.wikipedia.org/wiki/Electronic_computer",
        "https://en.wikipedia.org/wiki/Emacs",
        "https://en.wikipedia.org/wiki/Embedded_operating_system",
        "https://en.wikipedia.org/wiki/Embedded_system",
        "https://en.wikipedia.org/wiki/Freemium",
        "https://en.wikipedia.org/wiki/Free_software",
        "https://en.wikipedia.org/wiki/Free_Software_Foundation",
        "https://en.wikipedia.org/wiki/Free_software_license",
        "https://en.wikipedia.org/wiki/Freeware",
        "https://en.wikipedia.org/wiki/Frequency_analysis",
        "https://en.wikipedia.org/wiki/Gerald_Weinberg",
        "https://en.wikipedia.org/wiki/GitHub",
        "https://en.wikipedia.org/wiki/GNU_Debugger",
        "https://en.wikipedia.org/wiki/GNU_Project",
        "https://en.wikipedia.org/wiki/Google",
        "https://en.wikipedia.org/wiki/Graphics_processing_unit",
        "https://en.wikipedia.org/wiki/Hash_table",
        "https://en.wikipedia.org/wiki/Herman_Hollerith",
        "https://en.wikipedia.org/wiki/HTML",
        "https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol",
        "https://en.wikipedia.org/wiki/IBM_402_Accounting_Machine",
        "https://en.wikipedia.org/wiki/IBM_602",
        "https://en.wikipedia.org/wiki/IBM_604",
        "https://en.wikipedia.org/wiki/Indent_style",
        "https://en.wikipedia.org/wiki/Independent_software_vendor",
        "https://en.wikipedia.org/wiki/Infix_notation",
        "https://en.wikipedia.org/wiki/InformationWeek",
        "https://en.wikipedia.org/wiki/Institution_of_Analysts_and_Programmers",
        "https://en.wikipedia.org/wiki/IntelliJ_IDEA",
        "https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force",
        "https://en.wikipedia.org/wiki/JavaScript",
        "https://en.wikipedia.org/wiki/John_Wilder_Tukey",
        "https://en.wikipedia.org/wiki/JSTOR",
        "https://en.wikipedia.org/wiki/Killer_application",
        "https://en.wikipedia.org/wiki/List_of_software",
        "https://en.wikipedia.org/wiki/Low_level_language",
        "https://en.wikipedia.org/wiki/Mainframe_computer",
        "https://en.wikipedia.org/wiki/Maintainability",
        "https://en.wikipedia.org/wiki/Malicious_software",
        "https://en.wikipedia.org/wiki/Mathematical_Association_of_America",
        "https://en.wikipedia.org/wiki/Mathematical_proof",
        "https://en.wikipedia.org/wiki/Mathematics_in_medieval_Islam",
        "https://en.wikipedia.org/wiki/Memory_leak",
        "https://en.wikipedia.org/wiki/Microprocessor",
        "https://en.wikipedia.org/wiki/Microsoft_Notepad",
        "https://en.wikipedia.org/wiki/Microsoft_Office",
        "https://en.wikipedia.org/wiki/Microsoft_Visual_Studio",
        "https://en.wikipedia.org/wiki/Microsoft_Windows",
        "https://en.wikipedia.org/wiki/Microsoft_Word",
        "https://en.wikipedia.org/wiki/Mobile_app",
        "https://en.wikipedia.org/wiki/Mozilla_Foundation",
        "https://en.wikipedia.org/wiki/Multiprocessing",
        "https://en.wikipedia.org/wiki/Music_sequencer",
        "https://en.wikipedia.org/wiki/National_Coding_Week",
        "https://en.wikipedia.org/wiki/Noel_Sharkey",
        "https://en.wikipedia.org/wiki/NortonLifeLock",
        "https://en.wikipedia.org/wiki/Novell",
        "https://en.wikipedia.org/wiki/Object_code",
        "https://en.wikipedia.org/wiki/Object_file",
        "https://en.wikipedia.org/wiki/Object_hierarchy",
        "https://en.wikipedia.org/wiki/Oracle_Corporation",
        "https://en.wikipedia.org/wiki/Organised_Sound",
        "https://en.wikipedia.org/wiki/Outline_of_software",
        "https://en.wikipedia.org/wiki/Parsing",
        "https://en.wikipedia.org/wiki/Performance_engineering",
        "https://en.wikipedia.org/wiki/Personal_computer",
        "https://en.wikipedia.org/wiki/Personal_computer_hardware",
        "https://en.wikipedia.org/wiki/PHP",
        "https://en.wikipedia.org/wiki/Plugboard",
        "https://en.wikipedia.org/wiki/Procedural_programming",
        "https://en.wikipedia.org/wiki/Program_lifecycle_phase",
        "https://en.wikipedia.org/wiki/Programming_style",
        "https://en.wikipedia.org/wiki/Quicksort",
        "https://en.wikipedia.org/wiki/Race_condition",
        "https://en.wikipedia.org/wiki/Rand_Corporation",
        "https://en.wikipedia.org/wiki/Readability",
        "https://en.wikipedia.org/wiki/Regression_testing",
        "https://en.wikipedia.org/wiki/Requirements_analysis",
        "https://en.wikipedia.org/wiki/Reverse_engineering",
        "https://en.wikipedia.org/wiki/SAP_AG",
        "https://en.wikipedia.org/wiki/Scripting_language",
        "https://en.wikipedia.org/wiki/Security_hacker",
        "https://en.wikipedia.org/wiki/Separation_of_presentation_and_content",
        "https://en.wikipedia.org/wiki/Server_software",
        "https://en.wikipedia.org/wiki/Shared_library",
        "https://en.wikipedia.org/wiki/Shareware",
        "https://en.wikipedia.org/wiki/Smartphone",
        "https://en.wikipedia.org/wiki/Software",
        "https://en.wikipedia.org/wiki/Software_aging",
        "https://en.wikipedia.org/wiki/Software_architecture",
        "https://en.wikipedia.org/wiki/Software_asset_management",
        "https://en.wikipedia.org/wiki/Software_bug",
        "https://en.wikipedia.org/wiki/Software_developer",
        "https://en.wikipedia.org/wiki/Software_maintenance",
        "https://en.wikipedia.org/wiki/Software_portability",
        "https://en.wikipedia.org/wiki/Software_release_life_cycle",
        "https://en.wikipedia.org/wiki/Software_testing",
        "https://en.wikipedia.org/wiki/Software_utility",
        "https://en.wikipedia.org/wiki/Specification",
        "https://en.wikipedia.org/wiki/Spring_Framework",
        "https://en.wikipedia.org/wiki/Static_code_analysis",
        "https://en.wikipedia.org/wiki/Supercomputer",
        "https://en.wikipedia.org/wiki/Supervisory_program",
        "https://en.wikipedia.org/wiki/System_integration",
        "https://en.wikipedia.org/wiki/System_programming",
        "https://en.wikipedia.org/wiki/Tablet_computer",
        "https://en.wikipedia.org/wiki/Technical_support",
        "https://en.wikipedia.org/wiki/Temporary_file",
        "https://en.wikipedia.org/wiki/Timeline_of_women_in_computing",
        "https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface",
        "https://en.wikipedia.org/wiki/Unified_Modeling_Language",
        "https://en.wikipedia.org/wiki/Unit_record_equipment",
        "https://en.wikipedia.org/wiki/Unit_testing",
        "https://en.wikipedia.org/wiki/Usability",
        "https://en.wikipedia.org/wiki/Use_Case",
        "https://en.wikipedia.org/wiki/Vi",
        "https://en.wikipedia.org/wiki/Visual_programming_language",
        "https://en.wikipedia.org/wiki/Waterfall_model",
        "https://en.wikipedia.org/wiki/Web_application",
        "https://en.wikipedia.org/wiki/Web_browser",
        "https://en.wikipedia.org/wiki/Web_page",
        "https://en.wikipedia.org/wiki/Web_server",
        "https://en.wikipedia.org/wiki/Web_service",
        "https://en.wikipedia.org/wiki/Windows_Communication_Foundation",
        "https://en.wikipedia.org/wiki/Windows_Forms",
        "https://en.wikipedia.org/wiki/Window_system",
        "https://en.wikipedia.org/wiki/Women_in_computing",
        "https://en.wikipedia.org/wiki/Word_processor",
        "https://en.wikipedia.org/wiki/World_Scientific",
        "https://en.wikipedia.org/wiki/World_Wide_Web",
        "https://en.wikipedia.org/wiki/World_Wide_Web_Consortium",
        "https://en.wikipedia.org/wiki/XML",
        "https://en.wikipedia.org/wiki/IEEE_Annals_of_the_History_of_Computing",
        "https://en.wikipedia.org/wiki/Computer_program",
        "https://en.wikipedia.org/wiki/Computer_program",
        "https://en.wikipedia.org/wiki/Main_Page",
        "https://en.wikipedia.org/wiki/Main_Page"
    ]
}
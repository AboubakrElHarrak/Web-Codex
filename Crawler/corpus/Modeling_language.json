{
    "url": "https://en.wikipedia.org/wiki/Modeling_language",
    "title": "Modeling language",
    "table_of_contents": [
        "1 Overview",
        "2 Type of modeling languages",
        "2.1 Graphical types",
        "2.2 Textual types",
        "2.3 More specific types",
        "2.3.1 Algebraic",
        "2.3.2 Behavioral",
        "2.3.3 Discipline-specific",
        "2.3.4 Domain-specific",
        "2.3.5 Framework-specific",
        "2.3.6 Information and knowledge modeling",
        "2.3.7 Object-oriented",
        "2.3.8 Virtual reality",
        "2.3.9 Others",
        "3 Applications",
        "4 Quality",
        "4.1 Framework for evaluation",
        "4.1.1 Domain appropriateness",
        "4.1.2 Participant appropriateness",
        "4.1.3 Modeller appropriateness",
        "4.1.4 Comprehensibility appropriateness",
        "4.1.5 Tool appropriateness",
        "4.1.6 Organizational appropriateness",
        "5 See also",
        "6 References",
        "7 Further reading",
        "8 External links"
    ],
    "content": [
        {
            "paragraph1": "A modeling language is any artificial language that can be used to express information or knowledge or systems in a structure that is defined by a consistent set of rules. The rules are used for interpretation of the meaning of components in the structure.\n"
        },
        {
            "title": "Overview",
            "paragraph1": "A modeling language can be graphical or textual.\n",
            "ul1": "Graphical modeling languages use a diagram technique with named symbols that represent concepts and lines that connect the symbols and represent relationships and various other graphical notation to represent constraints.\nTextual modeling languages may use standardized keywords accompanied by parameters or natural language terms and phrases to make computer-interpretable expressions.\n",
            "paragraph2": "An example of a graphical modeling language and a corresponding textual modeling language is EXPRESS.\n",
            "paragraph3": "Not all modeling languages are executable, and for those that are, the use of them doesn't necessarily mean that programmers are no longer required. On the contrary, executable modeling languages are intended to amplify the productivity of skilled programmers, so that they can address more challenging problems, such as parallel computing and distributed systems.\n",
            "paragraph4": "A large number of modeling languages appear in the literature.\n"
        },
        {
            "title": "Type of modeling languages",
            "subtitle1": "Graphical types",
            "paragraph1": "Example of graphical modeling languages in the field of computer science, project management and systems engineering:\n",
            "ul1": "Behavior Trees are a formal, graphical modeling language used primarily in systems and software engineering. Commonly used to unambiguously represent the hundreds or even thousands of natural language requirements that are typically used to express the stakeholder needs for a large-scale software-integrated system.\nBusiness Process Modeling Notation (BPMN, and the XML form BPML) is an example of a Process Modeling language.\nC-K theory consists of a modeling language for design processes.\nDRAKON is a general-purpose algorithmic modeling language for specifying software-intensive systems, a schematic representation of an algorithm or a stepwise process, and a family of programming languages.\nEXPRESS and EXPRESS-G (ISO 10303-11) is an international standard general-purpose data modeling language.\nExtended Enterprise Modeling Language (EEML) is commonly used for business process modeling across a number of layers.\nFlowchart is a schematic representation of an algorithm or a stepwise process.\nFundamental Modeling Concepts (FMC) modeling language for software-intensive systems.\nIDEF is a family of modeling languages, which include IDEF0 for functional modeling, IDEF1X for information modeling, IDEF3 for business process modeling, IDEF4 for Object-Oriented Design and IDEF5 for modeling ontologies.\nJackson Structured Programming (JSP) is a method for structured programming based on correspondences between data stream structure and program structure.\nLePUS3 is an object-oriented visual Design Description Language and a formal specification language that is suitable primarily for modeling large object-oriented (Java, C++, C#) programs and design patterns.\nLifecycle Modeling Language is an open-standard language for systems engineering that supports the full system lifecycle: conceptual, utilization, support and retirement stages.\nObject-Role Modeling (ORM) in the field of software engineering is a method for conceptual modeling, and can be used as a tool for information and rules analysis.\nPetri nets use variations on exactly one diagramming technique and topology, namely the bipartite graph.  The simplicity of its basic user interface easily enabled extensive tool support over the years, particularly in the areas of model checking, graphically oriented simulation, and software verification.\nSouthbeach Notation is a visual modeling language used to describe situations in terms of agents that are considered useful or harmful from the modeler's perspective. The notation shows how the agents interact with each other and whether this interaction improves or worsens the situation.\nSpecification and Description Language (SDL) is a specification language targeted at the unambiguous specification and description of the behavior of reactive and distributed systems.\nSysML is a Domain-Specific Modeling language for systems engineering that is defined as a UML profile (customization).\nUnified Modeling Language (UML) is a general-purpose modeling language that is an industry standard for specifying software-intensive systems. UML 2.0, the current version, supports thirteen different diagram techniques, and has widespread tool support.\nService-oriented modeling framework (SOMF) is a holistic language for designing enterprise and application level architecture models in the space of enterprise architecture, virtualization, service-oriented architecture (SOA), cloud computing, and more.[2]\nArchitecture description language (ADL) is a language used to describe and represent the systems architecture of a system.\nAADL (AADL) is a modeling language that supports early and repeated analyses of a system's architecture with respect to performance-critical properties through an extendable notation, a tool framework, and precisely defined semantics.\n",
            "paragraph2": "Examples of graphical modeling languages in other fields of science.\n",
            "ul2": "EAST-ADL is a  Domain-Specific Modeling language dedicated to automotive system design.\nEnergy Systems Language (ESL), a language that aims to model ecological energetics & global economics.\nIEC 61499 defines Domain-Specific Modeling language dedicated to distribute industrial process measurement and control systems.\n",
            "subtitle2": "Textual types",
            "paragraph3": "Information models can also be expressed in formalized natural languages, such as Gellish. Gellish has natural language variants such as Gellish Formal English and Gellish Formal Dutch (Gellish Formeel Nederlands), etc. Gellish Formal English is an information representation language or semantic modeling language that is defined in the Gellish English Dictionary-Taxonomy, which has the form of a Taxonomy-Ontology (similarly for Dutch). Gellish Formal English is not only suitable to express knowledge, requirements and dictionaries, taxonomies and ontologies, but also information about individual things. All that information is expressed in one language and therefore it can all be integrated, independent of the question whether it is stored in central or distributed or in federated databases. Information models in Gellish Formal English consists of collections of Gellish Formal English expressions, that use natural language terms and formalized phrases. For example, a geographic information model might consist of a number of Gellish Formal English expressions, such as:\n",
            "paragraph4": "whereas information requirements and knowledge can be expressed for example as follows:\n",
            "paragraph5": "Such Gellish Formal English expressions use names of concepts (such as \"city\") and phrases that represent relation types (such as ⟨is located in⟩ and ⟨is classified as a⟩) that should be selected from the Gellish English Dictionary-Taxonomy (or of your own domain dictionary). The Gellish English Dictionary-Taxonomy enables the creation of semantically rich information models, because the dictionary contains more than 600 standard relation types and contains definitions of more than 40000 concepts. An information model in Gellish can express facts or make statements, queries and answers.\n",
            "subtitle3": "More specific types",
            "paragraph6": "In the field of computer science recently more specific types of modeling languages have emerged.\n",
            "paragraph7": "Algebraic Modeling Languages (AML) are high-level programming languages for describing and solving high complexity problems for large scale mathematical computation (i.e. large scale optimization type problems). One particular advantage of AMLs like AIMMS, AMPL, GAMS, Mosel,  OPL and OptimJ is the similarity of its syntax to the mathematical notation of optimization problems. This allows for a very concise and readable definition of problems in the domain of optimization, which is supported by certain language elements like sets, indices, algebraic expressions, powerful sparse index and data handling variables, constraints with arbitrary names. The algebraic formulation of a model does not contain any hints how to process it.\n",
            "paragraph8": "Behavioral languages are designed to describe the observable behavior of complex systems consisting of components that\nexecute concurrently. These languages focus on the description of key concepts such as: concurrency, nondeterminism, synchronization, and communication. The semantic foundations of Behavioral languages are process calculus or process algebra.\n",
            "paragraph9": "A discipline-specific modeling (DspM) language is focused on deliverables affiliated with a specific software development life cycle stage. Therefore, such language offers a distinct vocabulary, syntax, and notation for each stage, such as discovery, analysis, design, architecture, contraction, etc. For example, for the analysis phase of a project, the modeler employs specific analysis notation to deliver an analysis proposition diagram. During the design phase, however, logical design notation is used to depict relationship between software entities. In addition, the discipline-specific modeling language best practices does not preclude practitioners from combining the various notations in a single diagram.\n",
            "paragraph10": "Domain-specific modeling (DSM) is a software engineering methodology for designing and developing systems, most often IT systems such as computer software. It involves systematic use of a graphical domain-specific language (DSL) to represent the various facets of a system. DSM languages tend to support higher-level abstractions than General-purpose modeling languages, so they require less effort and fewer low-level details to specify a given system.\n",
            "paragraph11": "A framework-specific modeling language (FSML) is a kind of domain-specific modeling language which is designed for an object-oriented application framework. FSMLs define framework-provided abstractions as FSML concepts and decompose the abstractions into features. The features represent implementation steps or choices.\n",
            "paragraph12": "A FSML concept can be configured by selecting features and providing values for features. Such a concept configuration represents how the concept should be implemented in the code. In other words, concept configuration describes how the framework should be completed in order to create the implementation of the concept.\n",
            "paragraph13": "Linked data and ontology engineering require 'host languages' to represent entities and the relations between them, constraints between the properties of entities and relations, and metadata attributes. JSON-LD and RDF are two major (and semantically almost equivalent) languages in this context, primarily because they support statement reification and contextualisation which are essential properties to support the higher-order logic needed to reason about models. Model transformation is a common example of such reasoning.\n",
            "paragraph14": "Object modeling languages are modeling languages based on a standardized set of symbols and ways of arranging them to model (part of) an object oriented software design or system design.\n",
            "paragraph15": "Some organizations use them extensively in combination with a software development methodology to progress from initial specification to an implementation plan and to communicate that plan to an entire team of developers and stakeholders. Because a modeling language is visual and at a higher-level of abstraction than code, using models encourages the generation of a shared vision that may prevent problems of differing interpretation later in development. Often software modeling tools are used to construct these models, which may then be capable of automatic translation to code.\n",
            "paragraph16": "Virtual Reality Modeling Language (VRML), before 1995 known as the Virtual Reality Markup Language is a standard file format for representing 3-dimensional (3D) interactive vector graphics, designed particularly with the World Wide Web in mind.\n",
            "ul3": "Architecture Description Language\nFace Modeling Language\nGenerative Modelling Language\nJava Modeling Language\nPromela\nRebeca Modeling Language\nService Modeling Language\nWeb Services Modeling Language\nX3D\n"
        },
        {
            "title": "Applications",
            "paragraph1": "Various kinds of modeling languages are applied in different disciplines, including computer science, information management, business process modeling, software engineering, and systems engineering. Modeling languages can be used to specify:\n",
            "ul1": "system requirements,\nstructures and\nbehaviors.\n",
            "paragraph2": "Modeling languages are intended to be used to precisely specify systems so that stakeholders (e.g., customers, operators, analysts, designers) can better understand the system being modeled.\n",
            "paragraph3": "The more mature modeling languages are precise, consistent and executable. Informal diagramming techniques applied with drawing tools are expected to produce useful pictorial representations of system requirements, structures and behaviors, which can be useful for communication, design, and problem solving but cannot be used programmatically.: 539  Executable modeling languages applied with proper tool support, however, are expected to automate system verification and validation, simulation and code generation from the same representations.\n"
        },
        {
            "title": "Quality",
            "paragraph1": "A review of modelling languages is essential to be able to assign which languages are appropriate for different modelling settings. In the term settings we include stakeholders, domain and the knowledge connected. Assessing the language quality is a means that aims to achieve better models.\n",
            "subtitle1": "Framework for evaluation",
            "paragraph2": "Here language quality is stated in accordance with the SEQUAL framework for quality of models developed by Krogstie, Sindre and Lindland (2003), since this is a framework that connects the language quality to a framework for general model quality. Five areas are used in this framework to describe language quality and these are supposed to express both the conceptual as well as the visual notation of the language. We will not go into a thoroughly explanation of the underlying quality framework of models but concentrate on the areas used to explain the language quality framework.\n",
            "paragraph3": "The framework states the ability to represent the domain as domain appropriateness. The statement appropriateness can be a bit vague, but in this particular context it means able to express. You should ideally only be able to express things that are in the domain but be powerful enough to include everything that is in the domain. This requirement might seem a bit strict, but the aim is to get a visually expressed model which includes everything relevant to the domain and excludes everything not appropriate for the domain. To achieve this, the language has to have a good distinction of which notations and syntaxes that are advantageous to present.\n",
            "paragraph4": "To evaluate the participant appropriateness we try to identify how well the language expresses the knowledge held by the stakeholders. This involves challenges since a stakeholder's knowledge is subjective. The knowledge of the stakeholder is both tacit and explicit. Both types of knowledge are of dynamic character. In this framework only the explicit type of knowledge is taken into account. The language should to a large extent express all the explicit knowledge of the stakeholders relevant to the domain.\n",
            "paragraph5": "Last paragraph stated that knowledge of the stakeholders should be presented in a good way. In addition it is imperative that the language should be able to express all possible explicit knowledge of the stakeholders. No knowledge should be left unexpressed due to lacks in the language.\n",
            "paragraph6": "Comprehensibility appropriateness makes sure that the social actors understand the model due to a consistent use of the language. To achieve this the framework includes a set of criteria. The general importance that these express is that the language should be flexible, easy to organize and easy to distinguish different parts of the language internally as well as from other languages. In addition to this, the goal should be as simple as possible and that each symbol in the language has a unique representation.\n",
            "paragraph7": "This is in connection to also to the structure of the development requirements. \n.\n",
            "paragraph8": "To ensure that the domain actually modelled is usable for analyzing and further processing, the language has to ensure that it is possible to reason in an automatic way. To achieve this it has to include formal syntax and semantics. Another advantage by formalizing is the ability to discover errors in an early stage. It is not always that the language best fitted for the technical actors is the same as for the social actors.\n",
            "paragraph9": "The language used is appropriate for the organizational context, e.g. that the language is standardized within the organization, or that it is supported by tools that are chosen as standard in the organization.\n"
        }
    ],
    "links": [
        "https://en.wikipedia.org/wiki/Artificial_language",
        "https://en.wikipedia.org/wiki/Information",
        "https://en.wikipedia.org/wiki/Knowledge",
        "https://en.wikipedia.org/wiki/System",
        "https://en.wikipedia.org/wiki/Structure",
        "https://en.wikipedia.org/wiki/Diagramming_technique",
        "https://en.wikipedia.org/wiki/Parallel_computing",
        "https://en.wikipedia.org/wiki/Distributed_system",
        "https://en.wikipedia.org/wiki/Behavior_Trees",
        "https://en.wikipedia.org/wiki/Systems_engineering",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Natural_language",
        "https://en.wikipedia.org/wiki/Project_stakeholder",
        "https://en.wikipedia.org/wiki/Business_Process_Modeling_Notation",
        "https://en.wikipedia.org/wiki/XML",
        "https://en.wikipedia.org/wiki/Process_Modeling",
        "https://en.wikipedia.org/wiki/DRAKON",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Data_modeling",
        "https://en.wikipedia.org/wiki/Extended_Enterprise_Modeling_Language",
        "https://en.wikipedia.org/wiki/Flowchart",
        "https://en.wikipedia.org/wiki/Fundamental_Modeling_Concepts",
        "https://en.wikipedia.org/wiki/IDEF",
        "https://en.wikipedia.org/wiki/IDEF0",
        "https://en.wikipedia.org/wiki/IDEF1X",
        "https://en.wikipedia.org/wiki/IDEF3",
        "https://en.wikipedia.org/wiki/IDEF4",
        "https://en.wikipedia.org/wiki/IDEF5",
        "https://en.wikipedia.org/wiki/Jackson_Structured_Programming",
        "https://en.wikipedia.org/wiki/Lepus3",
        "https://en.wikipedia.org/wiki/Formal_specification",
        "https://en.wikipedia.org/wiki/Design_patterns",
        "https://en.wikipedia.org/wiki/Lifecycle_Modeling_Language",
        "https://en.wikipedia.org/wiki/Systems_engineering",
        "https://en.wikipedia.org/wiki/System_lifecycle",
        "https://en.wikipedia.org/wiki/Petri_net",
        "https://en.wikipedia.org/wiki/Bipartite_graph",
        "https://en.wikipedia.org/wiki/Specification_and_Description_Language",
        "https://en.wikipedia.org/wiki/SysML",
        "https://en.wikipedia.org/wiki/Systems_engineering",
        "https://en.wikipedia.org/wiki/Unified_Modeling_Language",
        "https://en.wikipedia.org/wiki/Architecture_description_language",
        "https://en.wikipedia.org/wiki/Systems_architecture",
        "https://en.wikipedia.org/wiki/System",
        "https://en.wikipedia.org/wiki/Energy_Systems_Language",
        "https://en.wikipedia.org/wiki/IEC_61499",
        "https://en.wikipedia.org/wiki/Gellish_English",
        "https://en.wikipedia.org/wiki/Computer_science",
        "https://en.wikipedia.org/wiki/Algebraic_modeling_language",
        "https://en.wikipedia.org/wiki/AIMMS",
        "https://en.wikipedia.org/wiki/AMPL",
        "https://en.wikipedia.org/wiki/General_Algebraic_Modeling_System",
        "https://en.wikipedia.org/wiki/FICO_Xpress",
        "https://en.wikipedia.org/wiki/OPL_Development_Studio",
        "https://en.wikipedia.org/wiki/OptimJ",
        "https://en.wikipedia.org/wiki/Process_calculus",
        "https://en.wikipedia.org/wiki/Process_algebra",
        "https://en.wikipedia.org/wiki/Linked_data",
        "https://en.wikipedia.org/wiki/Ontology_engineering",
        "https://en.wikipedia.org/wiki/Metadata",
        "https://en.wikipedia.org/wiki/Resource_Description_Framework",
        "https://en.wikipedia.org/wiki/Model_transformation",
        "https://en.wikipedia.org/wiki/Object_modeling_language",
        "https://en.wikipedia.org/wiki/VRML",
        "https://en.wikipedia.org/wiki/Architecture_Description_Language",
        "https://en.wikipedia.org/wiki/Face_Modeling_Language",
        "https://en.wikipedia.org/wiki/Generative_Modelling_Language",
        "https://en.wikipedia.org/wiki/Java_Modeling_Language",
        "https://en.wikipedia.org/wiki/Promela",
        "https://en.wikipedia.org/wiki/Rebeca_Modeling_Language",
        "https://en.wikipedia.org/wiki/Service_Modeling_Language",
        "https://en.wikipedia.org/wiki/Web_Services_Modeling_Language",
        "https://en.wikipedia.org/wiki/X3D",
        "https://en.wikipedia.org/wiki/Computer_science",
        "https://en.wikipedia.org/wiki/Information_management",
        "https://en.wikipedia.org/wiki/Business_process_modeling",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Systems_engineering",
        "https://en.wikipedia.org/wiki/Verification_and_validation",
        "https://en.wikipedia.org/wiki/Simulation",
        "https://en.wikipedia.org/wiki/Automatic_programming",
        "https://en.wikipedia.org/wiki/SEQUAL_framework",
        "https://en.wikipedia.org/wiki/Syntax",
        "https://en.wikipedia.org/wiki/Analogical_models",
        "https://en.wikipedia.org/wiki/Anthropomorphism",
        "https://en.wikipedia.org/wiki/Metamodeling",
        "https://en.wikipedia.org/wiki/Modeling_perspective",
        "https://en.wikipedia.org/wiki/Ontology_language",
        "https://en.wikipedia.org/wiki/Scientific_modelling",
        "https://en.wikipedia.org/wiki/Visual_modeling",
        "https://en.wikipedia.org/wiki/Visual_programming_language",
        "https://en.wikipedia.org/wiki/Wayback_Machine",
        "https://en.wikipedia.org/wiki/John_Krogstie",
        "https://en.wikipedia.org/wiki/John_Krogstie",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Computer_programming",
        "https://en.wikipedia.org/wiki/DevOps",
        "https://en.wikipedia.org/wiki/Requirements_engineering",
        "https://en.wikipedia.org/wiki/Site_reliability_engineering",
        "https://en.wikipedia.org/wiki/Software_deployment",
        "https://en.wikipedia.org/wiki/Software_design",
        "https://en.wikipedia.org/wiki/Software_maintenance",
        "https://en.wikipedia.org/wiki/Software_testing",
        "https://en.wikipedia.org/wiki/Systems_analysis",
        "https://en.wikipedia.org/wiki/Formal_methods",
        "https://en.wikipedia.org/wiki/Data_modeling",
        "https://en.wikipedia.org/wiki/Enterprise_architecture",
        "https://en.wikipedia.org/wiki/Functional_specification",
        "https://en.wikipedia.org/wiki/Programming_paradigm",
        "https://en.wikipedia.org/wiki/Software",
        "https://en.wikipedia.org/wiki/Software_archaeology",
        "https://en.wikipedia.org/wiki/Software_architecture",
        "https://en.wikipedia.org/wiki/Software_configuration_management",
        "https://en.wikipedia.org/wiki/Software_development_process",
        "https://en.wikipedia.org/wiki/Software_quality",
        "https://en.wikipedia.org/wiki/Software_quality_assurance",
        "https://en.wikipedia.org/wiki/Software_verification_and_validation",
        "https://en.wikipedia.org/wiki/Structured_analysis",
        "https://en.wikipedia.org/wiki/Essential_Systems_Analysis",
        "https://en.wikipedia.org/wiki/Agile_software_development",
        "https://en.wikipedia.org/wiki/Systems_development_life_cycle",
        "https://en.wikipedia.org/wiki/Agile_software_development",
        "https://en.wikipedia.org/wiki/Enterprise_Unified_Process",
        "https://en.wikipedia.org/wiki/Executable_UML",
        "https://en.wikipedia.org/wiki/Incremental_build_model",
        "https://en.wikipedia.org/wiki/Iterative_and_incremental_development",
        "https://en.wikipedia.org/wiki/Software_prototyping",
        "https://en.wikipedia.org/wiki/Rapid_application_development",
        "https://en.wikipedia.org/wiki/Unified_Process",
        "https://en.wikipedia.org/wiki/Spiral_model",
        "https://en.wikipedia.org/wiki/Waterfall_model",
        "https://en.wikipedia.org/wiki/Extreme_programming",
        "https://en.wikipedia.org/wiki/Capability_Maturity_Model_Integration",
        "https://en.wikipedia.org/wiki/Data_model",
        "https://en.wikipedia.org/wiki/Function_model",
        "https://en.wikipedia.org/wiki/Information_model",
        "https://en.wikipedia.org/wiki/Metamodeling",
        "https://en.wikipedia.org/wiki/Object_model",
        "https://en.wikipedia.org/wiki/Systems_modeling",
        "https://en.wikipedia.org/wiki/View_model",
        "https://en.wikipedia.org/wiki/IDEF",
        "https://en.wikipedia.org/wiki/Unified_Modeling_Language",
        "https://en.wikipedia.org/wiki/Universal_Systems_Language",
        "https://en.wikipedia.org/wiki/Systems_Modeling_Language",
        "https://en.wikipedia.org/wiki/Computer_science",
        "https://en.wikipedia.org/wiki/Computer_engineering",
        "https://en.wikipedia.org/wiki/Information_science",
        "https://en.wikipedia.org/wiki/Project_management",
        "https://en.wikipedia.org/wiki/Risk_management",
        "https://en.wikipedia.org/wiki/Systems_engineering",
        "https://en.wikipedia.org/wiki/Computer_language",
        "https://en.wikipedia.org/wiki/Architecture_description_language",
        "https://en.wikipedia.org/wiki/Hardware_description_language",
        "https://en.wikipedia.org/wiki/Knowledge_representation_language",
        "https://en.wikipedia.org/wiki/Markup_language",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Query_language",
        "https://en.wikipedia.org/wiki/Shading_language",
        "https://en.wikipedia.org/wiki/Specification_language",
        "https://en.wikipedia.org/wiki/Style_sheet_language",
        "https://en.wikipedia.org/wiki/Transformation_language",
        "https://en.wikipedia.org/wiki/List_of_programming_languages_by_type",
        "https://en.wikipedia.org/wiki/Modeling_language",
        "https://en.wikipedia.org/wiki/Modeling_language",
        "https://en.wikipedia.org/wiki/Main_Page",
        "https://en.wikipedia.org/wiki/Main_Page"
    ]
}
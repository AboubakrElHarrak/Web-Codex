{
    "url": "https://en.wikipedia.org/wiki/Goto",
    "title": "Goto",
    "table_of_contents": [
        "1 Usage",
        "2 Criticism",
        "3 Common usage patterns",
        "4 Alternatives",
        "4.1 Structured programming",
        "4.2 Exceptions",
        "4.3 Tail calls",
        "4.4 Coroutines",
        "4.5 Continuations",
        "4.6 Message passing",
        "5 Variations",
        "5.1 Computed GOTO and Assigned GOTO",
        "5.2 ALTER",
        "5.3 Perl GOTO",
        "5.4 Emulated GOTO",
        "5.5 PL/I label variables",
        "5.6 MS/DOS GOTO",
        "6 Language support",
        "7 See also",
        "8 Notes",
        "9 References"
    ],
    "content": [
        {
            "paragraph1": "GoTo (goto, GOTO, GO TO or other case combinations, depending on the programming language) is a statement found in many computer programming languages.  It performs a one-way transfer of control to another line of code; in contrast a function call normally returns control.  The jumped-to locations are usually identified using labels, though some languages use line numbers. At the machine code level, a goto is a form of branch or jump statement, in some cases combined with a stack adjustment. Many languages support the goto statement, and many do not (see § language support).\n",
            "paragraph2": "The structured program theorem proved that the goto statement is not necessary to write programs that can be expressed as flow charts; some combination of the three programming constructs of sequence, selection/choice, and repetition/iteration are sufficient for any computation that can be performed by a Turing machine, with the caveat that code duplication and additional variables may need to be introduced.\n",
            "paragraph3": "In the past there was considerable debate in academia and industry on the merits of the use of goto statements. Use of goto was formerly common, but since the advent of structured programming in the 1960s and 1970s its use has declined significantly. The primary criticism is that code that uses goto statements is harder to understand than alternative constructions. Goto remains in use in certain common usage patterns, but alternatives are generally used if available. Debates over its (more limited) uses continue in academia and software industry circles.\n"
        },
        {
            "title": "Usage",
            "paragraph1": "goto label\n",
            "paragraph2": "The goto statement is often combined with the if statement to cause a conditional transfer of control.\n",
            "paragraph3": "IF condition THEN goto label\n",
            "paragraph4": "Programming languages impose different restrictions with respect to the destination of a goto statement. For example, the C programming language does not permit a jump to a label contained within another function, however jumps within a single call chain are possible using the setjmp/longjmp functions.\n"
        },
        {
            "title": "Criticism",
            "paragraph1": "At the pre-ALGOL meeting held in 1959 Heinz Zemanek explicitly threw doubt on the necessity for GOTO statements; at the time no one[citation needed] paid attention to his remark, including Edsger W. Dijkstra, who later became the iconic opponent of GOTO. The 1970s and 1980s saw a decline in the use of GOTO statements in favor of the \"structured programming\" paradigm, with goto criticized as leading to \"unmaintainable spaghetti code\" (see below). Some programming style coding standards, for example the GNU Pascal Coding Standards, recommend against the use of GOTO statements. The Böhm–Jacopini proof (1966) did not settle the question of whether to adopt structured programming for software development, partly because the construction was more likely to obscure a program than to improve it because its application requires the introduction of additional local variables. It did, however, spark a prominent debate among computer scientists, educators, language designers and application programmers that saw a slow but steady shift away from the formerly ubiquitous use of the GOTO. Probably the most famous criticism of GOTO is a 1968 letter by Edsger Dijkstra called \"Go To Statement Considered Harmful\". In that letter Dijkstra argued that unrestricted GOTO statements should be abolished from higher-level languages because they complicated the task of analyzing and verifying the correctness of programs (particularly those involving loops). The letter itself sparked a debate, including a \"'GOTO Considered Harmful' Considered Harmful\" letter sent to Communications of the ACM (CACM) in March 1987, as well as further replies by other people, including Dijkstra's On a Somewhat Disappointing Correspondence.\n",
            "paragraph2": "An alternative viewpoint is presented in Donald Knuth's Structured Programming with go to Statements, which analyzes many common programming tasks and finds that in some of them GOTO is the optimal language construct to use. In The C Programming Language, Brian Kernighan and Dennis Ritchie warn that goto is \"infinitely abusable\", but also suggest that it could be used for end-of-function error handlers and for multi-level breaks from loops. These two patterns can be found in numerous subsequent books on C by other authors;\n a 2007 introductory textbook notes that the error handling pattern is a way to work around the \"lack of built-in exception handling within the C language\". Other programmers, including Linux kernel designer and coder Linus Torvalds or software engineer and book author Steve McConnell, also object to Dijkstra's point of view, stating that GOTOs can be a useful language feature, improving program speed, size and code clarity, but only when used in a sensible way by a comparably sensible programmer. According to computer science professor John Regehr, in 2013, there were about 100,000 instances of goto in the Linux kernel code.\n",
            "paragraph3": "Other academics took a more extreme viewpoint and argued that even instructions like break and return from the middle of loops are bad practice as they are not needed in the Böhm–Jacopini result, and thus advocated that loops should have a single exit point. For instance, Bertrand Meyer wrote in his 2009 textbook that instructions like break and continue \"are just the old goto in sheep's clothing\". A slightly modified form of the Böhm–Jacopini result, however, allows the avoidance of additional variables in structured programming, as long as multi-level breaks from loops are allowed. Because some languages like C don't allow multi-level breaks via their break keyword, some textbooks advise the programmer to use goto in such circumstances. The MISRA C 2004 standard bans goto, continue, as well as multiple return and break statements. The 2012 edition of the MISRA C standard downgraded the prohibition on goto from \"required\" to \"advisory\" status; the 2012 edition has an additional, mandatory rule that prohibits only backward, but not forward jumps with goto.\n",
            "paragraph4": "FORTRAN introduced structured programming constructs in 1978, and in successive revisions the relatively loose semantic rules governing the allowable use of goto were tightened; the \"extended range\" in which a programmer could use a GOTO to enter and leave a still-executing DO loop was removed from the language in 1978, and by 1995 several forms of Fortran GOTO, including the Computed GOTO and the Assigned GOTO, had been deleted.  Some widely used modern programming languages such as Java and Python lack the GOTO statement – see language support – though most provide some means of breaking out of a selection, or either breaking out of or moving on to the next step of an iteration. The viewpoint that disturbing the control flow in code is undesirable may be seen in the design of some programming languages, for instance Ada visually emphasizes label definitions using angle brackets.\n",
            "paragraph5": "Entry 17.10 in comp.lang.c FAQ list addresses the issue of GOTO use directly, stating\n"
        },
        {
            "title": "Common usage patterns",
            "paragraph1": "While overall usage of gotos has been declining, there are still situations in some languages where a goto provides the shortest and most straightforward way to express a program's logic (while it is possible to express the same logic without gotos, the equivalent code will be longer and often more difficult to understand). In other languages, there are structured alternatives, notably exceptions and tail calls.\n",
            "paragraph2": "Situations in which goto is often useful include:\n",
            "ul1": "To make the code more readable and easier to follow[15][28]\nTo make smaller programs, and get rid of code duplication[15][28]\nImplement a finite-state machine, using a state transition table and goto to switch between states (in absence of tail call elimination), particularly in automatically generated C code.[29] For example, goto in the canonical LR parser.\nImplementing multi-level break and continue if not directly supported in the language; this is a common idiom in C.[14] Although Java reserves the goto keyword, it doesn't actually implement it. Instead, Java implements labelled break and labelled continue statements.[30] According to the Java documentation, the use of gotos for multi-level breaks was the most common (90%) use of gotos in C.[31] Java was not the first language to take this approach—forbidding goto, but providing multi-level breaks— the BLISS programming language (more precisely the BLISS-11 version thereof) preceded it in this respect.[32]\nSurrogates for single-level break or continue (retry) statements when the potential introduction of additional loops could incorrectly affect the control flow. This practice has been observed in Netbsd code.[33]\nError handling (in absence of exceptions), particularly cleanup code such as resource deallocation.[11][14][33][29][34] C++ offers an alternative to goto statement for this use case, which is : Resource Acquisition Is Initialization (RAII) through using destructors or using try and catch exceptions used in Exception handling.[35] setjmp and longjmp are another alternative, and have the advantage of being able to unwind part of the call stack.\npopping the stack in, e.g., Algol, PL/I.\n",
            "paragraph3": "These uses are relatively common in C, but much less common in C++ or other languages with higher-level features. However, throwing and catching an exception inside a function can be extraordinarily inefficient in some languages; a prime example is Objective-C, where a goto is a much faster alternative.\n",
            "paragraph4": "Another use of goto statements is to modify poorly factored legacy code, where avoiding a goto would require extensive refactoring or code duplication. For example, given a large function where only certain code is of interest, a goto statement allows one to jump to or from only the relevant code, without otherwise modifying the function. This usage is considered code smell, but finds occasional use.\n"
        },
        {
            "title": "Alternatives",
            "subtitle1": "Structured programming",
            "paragraph1": "The modern notion of subroutine was invented by David Wheeler when programming the EDSAC. To implement a call and return on a machine without a subroutine call instruction, he used a special pattern of self-modifying code, known as a Wheeler jump. This resulted in the ability to structure programs using well-nested executions of routines drawn from a library. This would not have been possible using only goto, since the target code, being drawn from the library, would not know where to jump back to.\n",
            "paragraph2": "Later, high-level languages such as Pascal were designed around support for structured programming, which generalized from subroutines (also known as procedures or functions) towards\nfurther control structures such as:\n",
            "ul1": "Loops using while, repeat until or do, and for statements\nswitch a.k.a. case statements, a form of multiway branching\n",
            "paragraph3": "These new language mechanisms replaced equivalent flows which previously would have been written using gotos and ifs.  Multi-way branching replaces the \"computed goto\" in which the instruction to jump to is determined dynamically (conditionally).\n",
            "paragraph4": "Under certain conditions it is possible to eliminate local go to statements of legacy programs by replacing them with multilevel loop exit statements.\n",
            "subtitle2": "Exceptions",
            "paragraph5": "In practice, a strict adherence to the basic three-structure template of structured programming yields highly nested code, due to inability to exit a structured unit prematurely, and a combinatorial explosion with quite complex program state data to handle all possible conditions.\n",
            "paragraph6": "Two solutions have been generally adopted: a way to exit a structured unit prematurely, and more generally exceptions – in both cases these go up the structure, returning control to enclosing blocks or functions, but do not jump to arbitrary code locations. These are analogous to the use of a return statement in non-terminal position – not strictly structured, due to early exit, but a mild relaxation of the strictures of structured programming. In C, break and continue allow one to terminate a loop or continue to the next iteration, without requiring an extra while or if statement. In some languages multi-level breaks are also possible. For handling exceptional situations, specialized exception handling constructs were added, such as try/catch/finally in Java.\n",
            "paragraph7": "The throw-catch exception handling mechanisms can also be easily abused to create non-transparent control structures, just like goto can be abused.\n",
            "subtitle3": "Tail calls",
            "paragraph8": "In a paper delivered to the ACM conference in Seattle in 1977, Guy L. Steele summarized the debate over the GOTO and structured programming, and observed that procedure calls in the tail position of a procedure can be most optimally treated as a direct transfer of control to the called procedure, typically eliminating unnecessary stack manipulation operations. Since such \"tail calls\" are very common in Lisp, a language where procedure calls are ubiquitous, this form of optimization considerably reduces the cost of a procedure call compared to the GOTO used in other languages.  Steele argued that poorly implemented procedure calls had led to an artificial perception that the GOTO was cheap compared to the procedure call. Steele further argued that \"in general procedure calls may be usefully thought of as GOTO statements which also pass parameters, and can be uniformly coded as machine code JUMP instructions\", with the machine code stack manipulation instructions \"considered an optimization (rather than vice versa!)\". Steele cited evidence that well optimized numerical algorithms in Lisp could execute faster than code produced by then-available commercial Fortran compilers because the cost of a procedure call in Lisp was much lower.  In Scheme, a Lisp dialect developed by Steele with Gerald Jay Sussman, tail call optimization is mandatory.\n",
            "paragraph9": "Although Steele's paper did not introduce much that was new to computer science, at least as it was practised at MIT, it brought to light the scope for procedure call optimization, which made the modularity-promoting qualities of procedures into a more credible alternative to the then-common coding habits of large monolithic procedures with complex internal control structures and extensive state data.  In particular, the tail call optimizations discussed by Steele turned the procedure into a credible way of implementing iteration through single tail recursion (tail recursion calling the same function). Further, tail call optimization allows mutual recursion of unbounded depth, assuming tail calls – this allows transfer of control, as in finite state machines, which otherwise is generally accomplished with goto statements.\n",
            "subtitle4": "Coroutines",
            "paragraph10": "Coroutines are a more radical relaxation of structured programming, allowing not only multiple exit points (as in returns in non-tail position), but also multiple entry points, similar to goto statements. Coroutines are more restricted than goto, as they can only resume a currently running coroutine at specified points – continuing after a yield – rather than jumping to an arbitrary point in the code. A limited form of coroutines are generators, which are sufficient for some purposes. Even more limited are closures – subroutines which maintain state (via static variables), but not execution position. A combination of state variables and structured control, notably an overall switch statement, can allow a subroutine to resume execution at an arbitrary point on subsequent calls, and is a structured alternative to goto statements in the absence of coroutines; this is a common idiom in C, for example.\n",
            "subtitle5": "Continuations",
            "paragraph11": "A continuation is similar to a GOTO in that it transfers control from an arbitrary point in the program to a previously marked point. A continuation is more flexible than GOTO in those languages that support it, because it can transfer control out of the current function, something that a GOTO cannot do in most structured programming languages.  In those language implementations that maintain stack frames for storage of local variables and function arguments, executing a continuation involves adjusting the program's call stack in addition to a jump. The longjmp function of the C programming language is an example of an escape continuation that may be used to escape the current context to a surrounding one.  The Common Lisp GO operator also has this stack unwinding property, despite the construct being lexically scoped, as the label to be jumped to can be referenced from a closure.\n",
            "paragraph12": "In Scheme, continuations can even move control from an outer context to an inner one if desired. This almost limitless control over what code is executed next makes complex control structures such as coroutines and cooperative multitasking relatively easy to write.\n",
            "subtitle6": "Message passing",
            "paragraph13": "In non-procedural paradigms, goto is less relevant or completely absent. One of the main alternatives is message passing, which is of particular importance in concurrent computing, interprocess communication, and object oriented programming. In these cases, the individual components do not have arbitrary transfer of control, but the overall control may be scheduled in complex ways, such as via preemption. The influential languages Simula and Smalltalk were among the first to introduce the concepts of messages and objects.  By encapsulating state data, object-oriented programming reduced software complexity to interactions (messages) between objects.\n"
        },
        {
            "title": "Variations",
            "paragraph1": "There are a number of different language constructs under the class of goto statements.\n",
            "subtitle1": "Computed GOTO and Assigned GOTO",
            "paragraph2": "In Fortran, a computed GOTO jumps to one of several labels in a list, based on the value of an expression. An example is goto (20,30,40) i. The equivalent construct in C is the switch statement and in newer Fortran a CASE statement is the recommend syntactical alternative. BASIC had a 'On GoTo' statement that achieved the same goal, but in Visual Basic this construct is no longer supported.\n",
            "paragraph3": "In versions prior to Fortran 95, Fortran also had an assigned goto variant that transfers control to a statement label (line number) which is stored in (assigned to) an integer variable. Jumping to an integer variable that had not been ASSIGNed to was unfortunately possible, and was a major source of bugs involving assigned gotos. The Fortran assign statement only allows a constant (existing) line number to be assigned to the integer variable. However, it was possible to accidentally treat this variable as an integer thereafter, for example increment it, resulting in unspecified behavior at goto time. The following code demonstrates the behavior of the goto i when line i is unspecified:\n",
            "paragraph4": "Several C compilers implement two non-standard C/C++ extensions relating to gotos originally introduced by gcc. The GNU extension allows the address of a label inside the current function to be obtained as a void* using the unary, prefix label value operator &&. The goto instruction is also extended to allow jumping to an arbitrary void* expression. This C extension is referred to as a computed goto in documentation of the C compilers that support it; its semantics are a superset of Fortran's assigned goto, because it allows arbitrary pointer expressions as the goto target, while Fortran's assigned goto doesn't allow arbitrary expressions as jump target. As with the standard goto in C, the GNU C extension allows the target of the computed goto to reside only in the current function. Attempting to jump outside the current function results in unspecified behavior.\n",
            "paragraph5": "Some variants of BASIC also support a computed GOTO in the sense used in GNU C, i.e. in which the target can be any line number, not just one from a list. For example, in MTS BASIC one could write GOTO i*1000 to jump to the line numbered 1000 times the value of a variable i (which might represent a selected menu option, for example).\n",
            "paragraph6": "PL/I label variables achieve the effect of computed or assigned GOTOs.\n",
            "subtitle2": "ALTER",
            "paragraph7": "Up to the 1985 ANSI COBOL standard had the ALTER statement which could be used to change the destination of an existing GO TO, which had to be in a paragraph by itself. The feature, which allowed polymorphism, was frequently condemned and seldom used.\n",
            "subtitle3": "Perl GOTO",
            "paragraph8": "In Perl, there is a variant of the goto statement that is not a traditional GOTO statement at all. It takes a function name and transfers control by effectively substituting one function call for another (a tail call): the new function will not return to the GOTO, but instead to the place from which the original function was called.\n",
            "subtitle4": "Emulated GOTO",
            "paragraph9": "There are several programming languages that do not support GOTO by default. By using GOTO emulation, it is still possible to use GOTO in these programming languages, albeit with some restrictions. One can emulate GOTO in Java, JavaScript, and Python.\n",
            "subtitle5": "PL/I label variables",
            "paragraph10": "PL/I has the data type LABEL, which can be used to implement both the \"assigned goto\" and the \"computed goto.\"  PL/I allows branches out of the current block.  A calling procedure can pass a label as an argument to a called procedure which can then exit with a branch. The value of a label variable includes the address of a stack frame, and a goto out of block pops the stack.\n",
            "paragraph11": "A simpler way to get an equivalent result is using a label constant array that doesn't even need an explicit declaration of a LABEL type variable:\n",
            "subtitle6": "MS/DOS GOTO",
            "paragraph12": "Goto directs execution to a label that begins with a colon.\nThe target of the Goto can be a variable.\n"
        },
        {
            "title": "Language support",
            "paragraph1": "Many languages support the goto statement, and many do not. In Java, goto is a reserved word, but is unusable, although the compiled file.class generates GOTOs and LABELs. Python does not have support for goto, although there are several joke modules that provide it. There is no goto statement in Seed7 and hidden gotos like break- and continue-statements are also omitted. In PHP there was no native support for goto until version 5.3 (libraries were available to emulate its functionality).\n",
            "paragraph2": "The C# programming language has goto. However, it does not allow jumping to a label outside of the current scope, making it significantly less powerful and dangerous than the goto keyword in other programming languages. It also makes case and default statements labels, whose scope is the enclosing switch statement; goto case or goto default is often used as an explicit replacement for implicit fallthrough, which C# disallows.\n",
            "paragraph3": "The PL/I programing language has a GOTO statement that unwinds the stack for an out of block transfer and does not permit a transfer into a block from outside of it.\n",
            "paragraph4": "Other languages may have their own separate keywords for explicit fallthroughs, which can be considered a version of goto restricted to this specific purpose. For example, Go uses the fallthrough keyword and doesn't allow implicit fallthrough at all, while Perl 5 uses next for explicit fallthrough by default, but also allows setting implicit fallthrough as default behavior for a module.\n",
            "paragraph5": "Most languages that have goto statements call it that, but in the early days of computing, other names were used. For example, in MAD the TRANSFER TO statement was used. APL uses a right pointing arrow, → for goto.\n",
            "paragraph6": "C has goto, and it is commonly used in various idioms, as discussed above.\n",
            "paragraph7": "There is a goto function in Perl as well. (see above)\n",
            "paragraph8": "Functional programming languages such as Scheme generally do not have goto, instead using continuations.\n"
        }
    ],
    "links": [
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Subroutine",
        "https://en.wikipedia.org/wiki/Line_number",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Structured_program_theorem",
        "https://en.wikipedia.org/wiki/Flow_chart",
        "https://en.wikipedia.org/wiki/Turing_machine",
        "https://en.wikipedia.org/wiki/Code_duplication",
        "https://en.wikipedia.org/wiki/C_programming_language",
        "https://en.wikipedia.org/wiki/Setjmp",
        "https://en.wikipedia.org/wiki/Heinz_Zemanek",
        "https://en.wikipedia.org/wiki/Structured_programming",
        "https://en.wikipedia.org/wiki/Programming_paradigm",
        "https://en.wikipedia.org/wiki/Spaghetti_code",
        "https://en.wikipedia.org/wiki/Programming_style",
        "https://en.wikipedia.org/wiki/Structured_program_theorem",
        "https://en.wikipedia.org/wiki/Considered_Harmful",
        "https://en.wikipedia.org/wiki/Association_for_Computing_Machinery",
        "https://en.wikipedia.org/wiki/Donald_Knuth",
        "https://en.wikipedia.org/wiki/Language_construct",
        "https://en.wikipedia.org/wiki/The_C_Programming_Language",
        "https://en.wikipedia.org/wiki/Brian_Kernighan",
        "https://en.wikipedia.org/wiki/Dennis_Ritchie",
        "https://en.wikipedia.org/wiki/Linux",
        "https://en.wikipedia.org/wiki/Linus_Torvalds",
        "https://en.wikipedia.org/wiki/Steve_McConnell",
        "https://en.wikipedia.org/wiki/John_Regehr",
        "https://en.wikipedia.org/wiki/Bertrand_Meyer",
        "https://en.wikipedia.org/wiki/MISRA_C",
        "https://en.wikipedia.org/wiki/FORTRAN",
        "https://en.wikipedia.org/wiki/Break_statement",
        "https://en.wikipedia.org/wiki/State_transition_table",
        "https://en.wikipedia.org/wiki/Tail_call_elimination",
        "https://en.wikipedia.org/wiki/BLISS",
        "https://en.wikipedia.org/wiki/Netbsd",
        "https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization",
        "https://en.wikipedia.org/wiki/Exception_handling",
        "https://en.wikipedia.org/wiki/Setjmp",
        "https://en.wikipedia.org/wiki/Call_stack",
        "https://en.wikipedia.org/wiki/Legacy_code",
        "https://en.wikipedia.org/wiki/Refactoring",
        "https://en.wikipedia.org/wiki/Code_duplication",
        "https://en.wikipedia.org/wiki/Code_smell",
        "https://en.wikipedia.org/wiki/Subroutine",
        "https://en.wikipedia.org/wiki/EDSAC",
        "https://en.wikipedia.org/wiki/Wheeler_jump",
        "https://en.wikipedia.org/wiki/Structured_programming",
        "https://en.wikipedia.org/wiki/Subroutine",
        "https://en.wikipedia.org/wiki/Control_structures",
        "https://en.wikipedia.org/wiki/While_loop",
        "https://en.wikipedia.org/wiki/Do_while_loop",
        "https://en.wikipedia.org/wiki/For_loop",
        "https://en.wikipedia.org/wiki/Switch_statement",
        "https://en.wikipedia.org/wiki/Multiway_branch",
        "https://en.wikipedia.org/wiki/Exception_handling",
        "https://en.wikipedia.org/wiki/Combinatorial_explosion",
        "https://en.wikipedia.org/wiki/Exception_handling",
        "https://en.wikipedia.org/wiki/Break_statement",
        "https://en.wikipedia.org/wiki/Exception_handling",
        "https://en.wikipedia.org/wiki/Tail_call",
        "https://en.wikipedia.org/wiki/Machine_code",
        "https://en.wikipedia.org/wiki/Gerald_Jay_Sussman",
        "https://en.wikipedia.org/wiki/Tail_recursion",
        "https://en.wikipedia.org/wiki/Mutual_recursion",
        "https://en.wikipedia.org/wiki/Finite_state_machine",
        "https://en.wikipedia.org/wiki/Coroutine",
        "https://en.wikipedia.org/wiki/Coroutine",
        "https://en.wikipedia.org/wiki/Static_variable",
        "https://en.wikipedia.org/wiki/Continuation",
        "https://en.wikipedia.org/wiki/Continuation",
        "https://en.wikipedia.org/wiki/Call_stack",
        "https://en.wikipedia.org/wiki/Common_Lisp",
        "https://en.wikipedia.org/wiki/Lexical_scope",
        "https://en.wikipedia.org/wiki/Message_passing",
        "https://en.wikipedia.org/wiki/Message_passing",
        "https://en.wikipedia.org/wiki/Concurrent_computing",
        "https://en.wikipedia.org/wiki/Interprocess_communication",
        "https://en.wikipedia.org/wiki/Object_oriented_programming",
        "https://en.wikipedia.org/wiki/Simula",
        "https://en.wikipedia.org/wiki/Smalltalk",
        "https://en.wikipedia.org/wiki/Branch_table",
        "https://en.wikipedia.org/wiki/Fortran",
        "https://en.wikipedia.org/wiki/Switch_statement",
        "https://en.wikipedia.org/wiki/BASIC",
        "https://en.wikipedia.org/wiki/Visual_Basic",
        "https://en.wikipedia.org/wiki/GNU_Compiler_Collection",
        "https://en.wikipedia.org/wiki/Michigan_Terminal_System",
        "https://en.wikipedia.org/wiki/COBOL",
        "https://en.wikipedia.org/wiki/Perl",
        "https://en.wikipedia.org/wiki/Tail_call",
        "https://en.wikipedia.org/wiki/Reserved_word",
        "https://en.wikipedia.org/wiki/Seed7",
        "https://en.wikipedia.org/wiki/PHP",
        "https://en.wikipedia.org/wiki/Switch_statement",
        "https://en.wikipedia.org/wiki/Perl",
        "https://en.wikipedia.org/wiki/COMEFROM",
        "https://en.wikipedia.org/wiki/GOSUB",
        "https://en.wikipedia.org/wiki/Switch_statement",
        "https://en.wikipedia.org/wiki/Multiway_branch",
        "https://en.wikipedia.org/wiki/Unstructured_programming",
        "https://en.wikipedia.org/wiki/Considered_harmful",
        "https://en.wikipedia.org/wiki/University_of_Texas_at_Austin",
        "https://en.wikipedia.org/wiki/Addison_Wesley",
        "https://en.wikipedia.org/wiki/Edsger_Dijkstra",
        "https://en.wikipedia.org/wiki/University_of_Texas_at_Austin",
        "https://en.wikipedia.org/wiki/Free_Software_Foundation",
        "https://en.wikipedia.org/wiki/James_Gosling",
        "https://en.wikipedia.org/wiki/Bill_Joy",
        "https://en.wikipedia.org/wiki/Gilad_Bracha",
        "https://en.wikipedia.org/wiki/Brian_Kernighan",
        "https://en.wikipedia.org/wiki/Dennis_Ritchie",
        "https://en.wikipedia.org/wiki/Donald_Knuth",
        "https://en.wikipedia.org/wiki/Dexter_Kozen",
        "https://en.wikipedia.org/wiki/Microsoft",
        "https://en.wikipedia.org/wiki/Microsoft",
        "https://en.wikipedia.org/wiki/GitHub",
        "https://en.wikipedia.org/wiki/John_Regehr",
        "https://en.wikipedia.org/wiki/Bjarne_Stroustrup",
        "https://en.wikipedia.org/wiki/Linus_Torvalds",
        "https://en.wikipedia.org/wiki/Maurice_Wilkes",
        "https://en.wikipedia.org/wiki/Stanley_Gill",
        "https://en.wikipedia.org/wiki/The_Preparation_of_Programs_for_an_Electronic_Digital_Computer",
        "https://en.wikipedia.org/wiki/Goto",
        "https://en.wikipedia.org/wiki/Goto",
        "https://en.wikipedia.org/wiki/Main_Page",
        "https://en.wikipedia.org/wiki/Main_Page"
    ]
}
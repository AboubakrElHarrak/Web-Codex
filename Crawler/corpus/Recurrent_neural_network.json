{
    "url": "https://en.wikipedia.org/wiki/Recurrent_neural_network",
    "title": "Recurrent neural network",
    "table_of_contents": [
        "1 History",
        "1.1 LSTM",
        "2 Architectures",
        "2.1 Fully recurrent",
        "2.2 Elman networks and Jordan networks",
        "2.3 Hopfield",
        "2.3.1 Bidirectional associative memory",
        "2.4 Echo state",
        "2.5 Independently RNN (IndRNN)",
        "2.6 Recursive",
        "2.7 Neural history compressor",
        "2.8 Second order RNNs",
        "2.9 Long short-term memory",
        "2.10 Gated recurrent unit",
        "2.11 Bi-directional",
        "2.12 Continuous-time",
        "2.13 Hierarchical",
        "2.14 Recurrent multilayer perceptron network",
        "2.15 Multiple timescales model",
        "2.16 Neural Turing machines",
        "2.17 Differentiable neural computer",
        "2.18 Neural network pushdown automata",
        "2.19 Memristive Networks",
        "3 Training",
        "3.1 Gradient descent",
        "3.2 Global optimization methods",
        "4 Related fields and models",
        "5 Libraries",
        "6 Applications",
        "7 References",
        "8 Further reading",
        "9 External links"
    ],
    "content": [
        {
            "paragraph1": "A recurrent neural network (RNN) is a class of artificial neural networks where connections between nodes form a directed or undirected graph along a temporal sequence. This allows it to exhibit temporal dynamic behavior. Derived from feedforward neural networks, RNNs can use their internal state (memory) to process variable length sequences of inputs. This makes them applicable to tasks such as unsegmented, connected handwriting recognition or speech recognition. Recurrent neural networks are theoretically Turing complete and can run arbitrary programs to process arbitrary sequences of inputs.\n",
            "paragraph2": "The term \"recurrent neural network\" is used to refer to the class of networks with an infinite impulse response, whereas \"convolutional neural network\" refers to the class of finite impulse response. Both classes of networks exhibit temporal dynamic behavior. A finite impulse recurrent network is a directed acyclic graph that can be unrolled and replaced with a strictly feedforward neural network, while an infinite impulse recurrent network is a directed cyclic graph that can not be unrolled.\n",
            "paragraph3": "Both finite impulse and infinite impulse recurrent networks can have additional stored states, and the storage can be under direct control by the neural network. The storage can also be replaced by another network or graph if that incorporates time delays or has feedback loops. Such controlled states are referred to as gated state or gated memory, and are part of long short-term memory networks (LSTMs) and gated recurrent units. This is also called Feedback Neural Network (FNN).\n"
        },
        {
            "title": "History",
            "paragraph1": "Recurrent neural networks were based on David Rumelhart's work in 1986. Hopfield networks – a special kind of RNN – were (re-)discovered by John Hopfield in 1982. In 1993, a neural history compressor system solved a \"Very Deep Learning\" task that required more than 1000 subsequent layers in an RNN unfolded in time.\n",
            "subtitle1": "LSTM",
            "paragraph2": "Long short-term memory (LSTM) networks were invented by Hochreiter and Schmidhuber in 1997 and set accuracy records in multiple applications domains.\n",
            "paragraph3": "Around 2007, LSTM started to revolutionize speech recognition, outperforming traditional models in certain speech applications. In 2009, a Connectionist Temporal Classification (CTC)-trained LSTM network was the first RNN to win pattern recognition contests when it won several competitions in connected handwriting recognition. In 2014, the Chinese company Baidu used CTC-trained RNNs to break the 2S09 Switchboard Hub5'00 speech recognition dataset benchmark without using any traditional speech processing methods.\n",
            "paragraph4": "LSTM also improved large-vocabulary speech recognition and text-to-speech synthesis and was used in Google Android. In 2015, Google's speech recognition reportedly experienced a dramatic performance jump of 49%[citation needed] through CTC-trained LSTM.\n",
            "paragraph5": "LSTM broke records for improved machine translation, Language Modeling and Multilingual Language Processing. LSTM combined with convolutional neural networks (CNNs) improved automatic image captioning.\n"
        },
        {
            "title": "Architectures",
            "paragraph1": "RNNs come in many variants.\n",
            "subtitle1": "Fully recurrent",
            "image1": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/b/b5/Recurrent_neural_network_unfold.svg/440px-Recurrent_neural_network_unfold.svg.png",
                "caption": "\n\t\tCompressed (left) and unfolded (right) basic recurrent neural network.\n\t"
            },
            "paragraph2": "Fully recurrent neural networks (FRNN) connect the outputs of all neurons to the inputs of all neurons.  This is the most general neural network topology because all other topologies can be represented by setting some connection weights to zero to simulate the lack of connections between those neurons.  The illustration to the right may be misleading to many because practical neural network topologies are frequently organized in \"layers\" and the drawing gives that appearance.  However, what appears to be layers are, in fact, different steps in time of the same fully recurrent neural network.  The left-most item in the illustration shows the recurrent connections as the arc labeled 'v'.  It is \"unfolded\" in time to produce the appearance of layers.\n",
            "subtitle2": "Elman networks and Jordan networks",
            "image2": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Elman_srnn.png/440px-Elman_srnn.png",
                "caption": "\n\t\tThe Elman network\n\t"
            },
            "paragraph3": "An Elman network is a three-layer network (arranged horizontally as x, y, and z in the illustration) with the addition of a set of context units (u in the illustration). The middle (hidden) layer is connected to these context units fixed with a weight of one. At each time step, the input is fed forward and a learning rule is applied. The fixed back-connections save a copy of the previous values of the hidden units in the context units (since they propagate over the connections before the learning rule is applied). Thus the network can maintain a sort of state, allowing it to perform such tasks as sequence-prediction that are beyond the power of a standard multilayer perceptron.\n",
            "paragraph4": "Jordan networks are similar to Elman networks. The context units are fed from the output layer instead of the hidden layer. The context units in a Jordan network are also referred to as the state layer. They have a recurrent connection to themselves.\n",
            "paragraph5": "Elman and Jordan networks are also known as \"Simple recurrent networks\" (SRN).\n",
            "paragraph6": "Variables and functions\n",
            "ul1": "\n\n\n\n\nx\n\nt\n\n\n\n\n{\\displaystyle x_{t))\n\n: input vector\n\n\n\n\n\nh\n\nt\n\n\n\n\n{\\displaystyle h_{t))\n\n: hidden layer vector\n\n\n\n\n\ny\n\nt\n\n\n\n\n{\\displaystyle y_{t))\n\n: output vector\n\n\n\n\nW\n\n\n{\\displaystyle W}\n\n, \n\n\n\nU\n\n\n{\\displaystyle U}\n\n and \n\n\n\nb\n\n\n{\\displaystyle b}\n\n: parameter matrices and vector\n\n\n\n\n\nσ\n\nh\n\n\n\n\n{\\displaystyle \\sigma _{h))\n\n and \n\n\n\n\nσ\n\ny\n\n\n\n\n{\\displaystyle \\sigma _{y))\n\n: Activation functions\n",
            "subtitle3": "Hopfield",
            "paragraph7": "The Hopfield network is an RNN in which all connections across layers are equally sized. It requires stationary inputs and is thus not a general RNN, as it does not process sequences of patterns. However, it guarantees that it will converge. If the connections are trained using Hebbian learning then the Hopfield network can perform as robust content-addressable memory, resistant to connection alteration.\n",
            "paragraph8": "Introduced by Bart Kosko, a bidirectional associative memory (BAM) network is a variant of a Hopfield network that stores associative data as a vector. The bi-directionality comes from passing information through a matrix and its transpose. Typically, bipolar encoding is preferred to binary encoding of the associative pairs. Recently, stochastic BAM models using Markov stepping were optimized for increased network stability and relevance to real-world applications.\n",
            "paragraph9": "A BAM network has two layers, either of which can be driven as an input to recall an association and produce an output on the other layer.\n",
            "subtitle4": "Echo state",
            "paragraph10": "The echo state network (ESN) has a sparsely connected random hidden layer. The weights of output neurons are the only part of the network that can change (be trained). ESNs are good at reproducing certain time series. A variant for spiking neurons is known as a liquid state machine.\n",
            "subtitle5": "Independently RNN (IndRNN)",
            "paragraph11": "The Independently recurrent neural network (IndRNN) addresses the gradient vanishing and exploding problems in the traditional fully connected RNN. Each neuron in one layer only receives its own past state as context information (instead of full connectivity to all other neurons in this layer) and thus neurons are independent of each other's history. The gradient backpropagation can be regulated to avoid gradient vanishing and exploding in order to keep long or short-term memory. The cross-neuron information is explored in the next layers. IndRNN can be robustly trained with the non-saturated nonlinear functions such as ReLU. Using skip connections, deep networks can be trained.\n",
            "subtitle6": "Recursive",
            "paragraph12": "A recursive neural network is created by applying the same set of weights recursively over a differentiable graph-like structure by traversing the structure in topological order. Such networks are typically also trained by the reverse mode of automatic differentiation. They can process distributed representations of structure, such as logical terms. A special case of recursive neural networks is the RNN whose structure corresponds to a linear chain. Recursive neural networks have been applied to natural language processing. The Recursive Neural Tensor Network uses a tensor-based composition function for all nodes in the tree.\n",
            "subtitle7": "Neural history compressor",
            "paragraph13": "The neural history compressor is an unsupervised stack of RNNs. At the input level, it learns to predict its next input from the previous inputs. Only unpredictable inputs of some RNN in the hierarchy become inputs to the next higher level RNN, which therefore recomputes its internal state only rarely. Each higher level RNN thus studies a compressed representation of the information in the RNN below. This is done such that the input sequence can be precisely reconstructed from the representation at the highest level.\n",
            "paragraph14": "The system effectively minimises the description length or the negative logarithm of the probability of the data. Given a lot of learnable predictability in the incoming data sequence, the highest level RNN can use supervised learning to easily classify even deep sequences with long intervals between important events.\n",
            "paragraph15": "It is possible to distill the RNN hierarchy into two RNNs: the \"conscious\" chunker (higher level) and the \"subconscious\" automatizer (lower level). Once the chunker has learned to predict and compress inputs that are unpredictable by the automatizer, then the automatizer can be forced in the next learning phase to predict or imitate through additional units the hidden units of the more slowly changing chunker. This makes it easy for the automatizer to learn appropriate, rarely changing memories across long intervals. In turn, this helps the automatizer to make many of its once unpredictable inputs predictable, such that the chunker can focus on the remaining unpredictable events.\n",
            "paragraph16": "A generative model partially overcame the vanishing gradient problem of automatic differentiation or backpropagation in neural networks in 1992. In 1993, such a system solved a \"Very Deep Learning\" task that required more than 1000 subsequent layers in an RNN unfolded in time.\n",
            "subtitle8": "Second order RNNs",
            "paragraph17": "Second order RNNs use higher order weights \n\n\n\nw\n\n\n\n\ni\nj\nk\n\n\n\n\n{\\displaystyle w{}_{ijk))\n\n instead of the standard \n\n\n\nw\n\n\n\n\ni\nj\n\n\n\n\n{\\displaystyle w{}_{ij))\n\n weights, and states can be a product. This allows a direct mapping to a finite-state machine both in training, stability, and representation. Long short-term memory is an example of this but has no such formal mappings or proof of stability.\n",
            "subtitle9": "Long short-term memory",
            "image3": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Long_Short-Term_Memory.svg/440px-Long_Short-Term_Memory.svg.png",
                "caption": "\n\t\tLong short-term memory unit\n\t"
            },
            "paragraph18": "Long short-term memory (LSTM) is a deep learning system that avoids the vanishing gradient problem. LSTM is normally augmented by recurrent gates called \"forget gates\". LSTM prevents backpropagated errors from vanishing or exploding. Instead, errors can flow backwards through unlimited numbers of virtual layers unfolded in space. That is, LSTM can learn tasks that require memories of events that happened thousands or even millions of discrete time steps earlier. Problem-specific LSTM-like topologies can be evolved. LSTM works even given long delays between significant events and can handle signals that mix low and high frequency components.\n",
            "paragraph19": "Many applications use stacks of LSTM RNNs and train them by Connectionist Temporal Classification (CTC) to find an RNN weight matrix that maximizes the probability of the label sequences in a training set, given the corresponding input sequences. CTC achieves both alignment and recognition.\n",
            "paragraph20": "LSTM can learn to recognize context-sensitive languages unlike previous models based on hidden Markov models (HMM) and similar concepts.\n",
            "subtitle10": "Gated recurrent unit",
            "image4": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Gated_Recurrent_Unit.svg/440px-Gated_Recurrent_Unit.svg.png",
                "caption": "\n\t\tGated recurrent unit\n\t"
            },
            "paragraph21": "Gated recurrent units (GRUs) are a gating mechanism in recurrent neural networks introduced in 2014. They are used in the full form and several simplified variants. Their performance on polyphonic music modeling and speech signal modeling was found to be similar to that of long short-term memory. They have fewer parameters than LSTM, as they lack an output gate.\n",
            "subtitle11": "Bi-directional",
            "paragraph22": "Bi-directional RNNs use a finite sequence to predict or label each element of the sequence based on the element's past and future contexts. This is done by concatenating the outputs of two RNNs, one processing the sequence from left to right, the other one from right to left. The combined outputs are the predictions of the teacher-given target signals. This technique has been proven to be especially useful when combined with LSTM RNNs.\n",
            "subtitle12": "Continuous-time",
            "paragraph23": "A continuous-time recurrent neural network (CTRNN) uses a system of ordinary differential equations to model the effects on a neuron of the incoming inputs.\n",
            "paragraph24": "For a neuron \n\n\n\ni\n\n\n{\\displaystyle i}\n\n in the network with activation \n\n\n\n\ny\n\ni\n\n\n\n\n{\\displaystyle y_{i))\n\n, the rate of change of activation is given by:\n",
            "paragraph25": "Where:\n",
            "ul2": "\n\n\n\n\nτ\n\ni\n\n\n\n\n{\\displaystyle \\tau _{i))\n\n : Time constant of postsynaptic node\n\n\n\n\n\ny\n\ni\n\n\n\n\n{\\displaystyle y_{i))\n\n : Activation of postsynaptic node\n\n\n\n\n\n\n\n\ny\n˙\n\n\n\n\ni\n\n\n\n\n{\\displaystyle {\\dot {y))_{i))\n\n : Rate of change of activation of postsynaptic node\n\n\n\n\nw\n\n\n\n\nj\ni\n\n\n\n\n{\\displaystyle w{}_{ji))\n\n : Weight of connection from pre to postsynaptic node\n\n\n\n\nσ\n(\nx\n)\n\n\n{\\displaystyle \\sigma (x)}\n\n : Sigmoid of x e.g. \n\n\n\nσ\n(\nx\n)\n=\n1\n\n/\n\n(\n1\n+\n\ne\n\n−\nx\n\n\n)\n\n\n{\\displaystyle \\sigma (x)=1/(1+e^{-x})}\n\n.\n\n\n\n\n\ny\n\nj\n\n\n\n\n{\\displaystyle y_{j))\n\n : Activation of presynaptic node\n\n\n\n\n\nΘ\n\nj\n\n\n\n\n{\\displaystyle \\Theta _{j))\n\n : Bias of presynaptic node\n\n\n\n\n\nI\n\ni\n\n\n(\nt\n)\n\n\n{\\displaystyle I_{i}(t)}\n\n : Input (if any) to node\n",
            "paragraph26": "CTRNNs have been applied to evolutionary robotics where they have been used to address vision, co-operation, and minimal cognitive behaviour.\n",
            "paragraph27": "Note that, by the Shannon sampling theorem, discrete time recurrent neural networks can be viewed as continuous-time recurrent neural networks where the differential equations have transformed into equivalent difference equations. This transformation can be thought of as occurring after the post-synaptic node activation functions \n\n\n\n\ny\n\ni\n\n\n(\nt\n)\n\n\n{\\displaystyle y_{i}(t)}\n\n have been low-pass filtered but prior to sampling.\n",
            "subtitle13": "Hierarchical",
            "paragraph28": "Hierarchical RNNs connect their neurons in various ways to decompose hierarchical behavior into useful subprograms. Such hierarchical structures of cognition are present in theories of memory presented by philosopher Henri Bergson, whose philosophical views have inspired hierarchical models.\n",
            "subtitle14": "Recurrent multilayer perceptron network",
            "paragraph29": "Generally, a recurrent multilayer perceptron network (RMLP) network consists of cascaded subnetworks, each of which contains multiple layers of nodes.  Each of these subnetworks is feed-forward except for the last layer, which can have feedback connections.  Each of these subnets is connected only by feed-forward connections.\n",
            "subtitle15": "Multiple timescales model",
            "paragraph30": "A multiple timescales recurrent neural network (MTRNN) is a neural-based computational model that can simulate the functional hierarchy of the brain through self-organization that depends on spatial connection between neurons and on distinct types of neuron activities, each with distinct time properties. With such varied neuronal activities, continuous sequences of any set of behaviors are segmented into reusable primitives, which in turn are flexibly integrated into diverse sequential behaviors. The biological approval of such a type of hierarchy was discussed in the memory-prediction theory of brain function by Hawkins in his book On Intelligence.[citation needed] Such a hierarchy also agrees with theories of memory posited by philosopher Henri Bergson, which have been incorporated into an MTRNN model.\n",
            "subtitle16": "Neural Turing machines",
            "paragraph31": "Neural Turing machines (NTMs) are a method of extending recurrent neural networks by coupling them to external memory resources which they can interact with by attentional processes. The combined system is analogous to a Turing machine or Von Neumann architecture but is differentiable end-to-end, allowing it to be efficiently trained with gradient descent.\n",
            "subtitle17": "Differentiable neural computer",
            "paragraph32": "Differentiable neural computers (DNCs) are an extension of Neural Turing machines, allowing for the usage of fuzzy amounts of each memory address and a record of chronology.\n",
            "subtitle18": "Neural network pushdown automata",
            "paragraph33": "Neural network pushdown automata (NNPDA) are similar to NTMs, but tapes are replaced by analogue stacks that are differentiable and that are trained. In this way, they are similar in complexity to recognizers of context free grammars (CFGs).\n",
            "subtitle19": "Memristive Networks",
            "paragraph34": "Greg Snider of HP Labs describes a system of cortical computing with memristive nanodevices. The memristors (memory resistors) are implemented by thin film materials in which the resistance is electrically tuned via the transport of ions or oxygen vacancies within the film. DARPA's SyNAPSE project has funded IBM Research and HP Labs, in collaboration with the Boston University Department of Cognitive and Neural Systems (CNS), to develop neuromorphic architectures which may be based on memristive systems.\nMemristive networks are a particular type of physical neural network that have very similar properties to (Little-)Hopfield networks, as they have a continuous dynamics, have a limited memory capacity and they natural relax via the minimization of a function which is asymptotic to the Ising model. In this sense, the dynamics of a memristive circuit has the advantage compared to a Resistor-Capacitor network to have a more interesting non-linear behavior. From this point of view, engineering an analog memristive networks accounts to a peculiar type of neuromorphic engineering in which the device behavior depends on the circuit wiring, or topology.\n\n"
        },
        {
            "title": "Training",
            "subtitle1": "Gradient descent",
            "paragraph1": "Gradient descent is a first-order iterative optimization algorithm for finding the minimum of a function. In neural networks, it can be used to minimize the error term by changing each weight in proportion to the derivative of the error with respect to that weight, provided the non-linear activation functions are differentiable. Various methods for doing so were developed in the 1980s and early 1990s by Werbos, Williams, Robinson, Schmidhuber, Hochreiter, Pearlmutter and others.\n",
            "paragraph2": "The standard method is called \"backpropagation through time\" or BPTT, and is a generalization of back-propagation for feed-forward networks. Like that method, it is an instance of automatic differentiation in the reverse accumulation mode of Pontryagin's minimum principle. A more computationally expensive online variant is called \"Real-Time Recurrent Learning\" or RTRL, which is an instance of automatic differentiation in the forward accumulation mode with stacked tangent vectors. Unlike BPTT, this algorithm is local in time but not local in space.\n",
            "paragraph3": "In this context, local in space means that a unit's weight vector can be updated using only information stored in the connected units and the unit itself such that update complexity of a single unit is linear in the dimensionality of the weight vector. Local in time means that the updates take place continually (on-line) and depend only on the most recent time step rather than on multiple time steps within a given time horizon as in BPTT. Biological neural networks appear to be local with respect to both time and space.\n",
            "paragraph4": "For recursively computing the partial derivatives, RTRL has a time-complexity of O(number of hidden x number of weights) per time step for computing the Jacobian matrices, while BPTT only takes O(number of weights) per time step, at the cost of storing all forward activations within the given time horizon. An online hybrid between BPTT and RTRL with intermediate complexity exists, along with variants for continuous time.\n",
            "paragraph5": "A major problem with gradient descent for standard RNN architectures is that error gradients vanish exponentially quickly with the size of the time lag between important events. LSTM combined with a BPTT/RTRL hybrid learning method attempts to overcome these problems. This problem is also solved in the independently recurrent neural network (IndRNN) by reducing the context of a neuron to its own past state and the cross-neuron information can then be explored in the following layers. Memories of different range including long-term memory can be learned without the gradient vanishing and exploding problem.\n",
            "paragraph6": "The on-line algorithm called causal recursive backpropagation (CRBP), implements and combines BPTT and RTRL paradigms for locally recurrent networks. It works with the most general locally recurrent networks. The CRBP algorithm can minimize the global error term. This fact improves stability of the algorithm, providing a unifying view on gradient calculation techniques for recurrent networks with local feedback.\n",
            "paragraph7": "One approach to the computation of gradient information in RNNs with arbitrary architectures is based on signal-flow graphs diagrammatic derivation. It uses the BPTT batch algorithm, based on Lee's theorem for network sensitivity calculations. It was proposed by Wan and Beaufays, while its fast online version was proposed by Campolucci, Uncini and Piazza.\n",
            "subtitle2": "Global optimization methods",
            "paragraph8": "Training the weights in a neural network can be modeled as a non-linear global optimization problem. A target function can be formed to evaluate the fitness or error of a particular weight vector as follows: First, the weights in the network are set according to the weight vector. Next, the network is evaluated against the training sequence. Typically, the sum-squared-difference between the predictions and the target values specified in the training sequence is used to represent the error of the current weight vector. Arbitrary global optimization techniques may then be used to minimize this target function.\n",
            "paragraph9": "The most common global optimization method for training RNNs is genetic algorithms, especially in unstructured networks.\n",
            "paragraph10": "Initially, the genetic algorithm is encoded with the neural network weights in a predefined manner where one gene in the chromosome represents one weight link. The whole network is represented as a single chromosome. The fitness function is evaluated as follows:\n",
            "ul1": "Each weight encoded in the chromosome is assigned to the respective weight link of the network.\nThe training set is presented to the network which propagates the input signals forward.\nThe mean-squared-error is returned to the fitness function.\nThis function drives the genetic selection process.\n",
            "paragraph11": "Many chromosomes make up the population; therefore, many different neural networks are evolved until a stopping criterion is satisfied. A common stopping scheme is: \n",
            "ul2": "When the neural network has learnt a certain percentage of the training data or\nWhen the minimum value of the mean-squared-error is satisfied or\nWhen the maximum number of training generations has been reached.\n",
            "paragraph12": "The stopping criterion is evaluated by the fitness function as it gets the reciprocal of the mean-squared-error from each network during training. Therefore, the goal of the genetic algorithm is to maximize the fitness function, reducing the mean-squared-error.\n",
            "paragraph13": "Other global (and/or evolutionary) optimization techniques may be used to seek a good set of weights, such as simulated annealing or particle swarm optimization.\n"
        },
        {
            "title": "Related fields and models",
            "paragraph1": "RNNs may behave chaotically. In such cases, dynamical systems theory may be used for analysis.\n",
            "paragraph2": "They are in fact recursive neural networks with a particular structure: that of a linear chain. Whereas recursive neural networks operate on any hierarchical structure, combining child representations into parent representations, recurrent neural networks operate on the linear progression of time, combining the previous time step and a hidden representation into the representation for the current time step.\n",
            "paragraph3": "In particular, RNNs can appear as nonlinear versions of finite impulse response and infinite impulse response filters and also as a nonlinear autoregressive exogenous model (NARX).\n"
        },
        {
            "title": "Libraries",
            "ul1": "Apache Singa\nCaffe: Created by the Berkeley Vision and Learning Center (BVLC). It supports both CPU and GPU. Developed in C++, and has Python and MATLAB wrappers.\nChainer: The first stable deep learning library that supports dynamic, define-by-run neural networks. Fully in Python, production support for CPU, GPU, distributed training.\nDeeplearning4j: Deep learning in Java and Scala on multi-GPU-enabled Spark. A general-purpose deep learning library for the JVM production stack running on a C++ scientific computing engine. Allows the creation of custom layers. Integrates with Hadoop and Kafka.\nFlux: includes interfaces for RNNs, including GRUs and LSTMs, written in Julia.\nKeras: High-level, easy to use API, providing a wrapper to many other deep learning libraries.\nMicrosoft Cognitive Toolkit\nMXNet: a modern open-source deep learning framework used to train and deploy deep neural networks.\nPyTorch: Tensors and Dynamic neural networks in Python with strong GPU acceleration.\nTensorFlow: Apache 2.0-licensed Theano-like library with support for CPU, GPU and Google's proprietary TPU,[87] mobile\nTheano: The reference deep-learning library for Python with an API largely compatible with the popular NumPy library. Allows user to write symbolic mathematical expressions, then automatically generates their derivatives, saving the user from having to code gradients or backpropagation. These symbolic expressions are automatically compiled to CUDA code for a fast, on-the-GPU implementation.\nTorch (www.torch.ch): A scientific computing framework with wide support for machine learning algorithms, written in C and lua. The main author is Ronan Collobert, and it is now used at Facebook AI Research and Twitter.\n"
        },
        {
            "title": "Applications",
            "paragraph1": "Applications of recurrent neural networks include:\n",
            "ul1": "Machine translation[20]\nRobot control[88]\nTime series prediction[89][90][91]\nSpeech recognition[92][93][94]\nSpeech synthesis[95]\nBrain–computer interfaces[96]\nTime series anomaly detection[97]\nRhythm learning[98]\nMusic composition[99]\nGrammar learning[100][101][102]\nHandwriting recognition[103][104]\nHuman action recognition[105]\nProtein homology detection[106]\nPredicting subcellular localization of proteins[53]\nSeveral prediction tasks in the area of business process management[107]\nPrediction in medical care pathways[108]\n"
        }
    ],
    "links": [
        "https://en.wikipedia.org/wiki/Recursive_neural_network",
        "https://en.wikipedia.org/wiki/Machine_learning",
        "https://en.wikipedia.org/wiki/Data_mining",
        "https://en.wikipedia.org/wiki/Statistical_classification",
        "https://en.wikipedia.org/wiki/Cluster_analysis",
        "https://en.wikipedia.org/wiki/Regression_analysis",
        "https://en.wikipedia.org/wiki/Anomaly_detection",
        "https://en.wikipedia.org/wiki/Data_Cleaning",
        "https://en.wikipedia.org/wiki/Automated_machine_learning",
        "https://en.wikipedia.org/wiki/Association_rule_learning",
        "https://en.wikipedia.org/wiki/Reinforcement_learning",
        "https://en.wikipedia.org/wiki/Structured_prediction",
        "https://en.wikipedia.org/wiki/Feature_engineering",
        "https://en.wikipedia.org/wiki/Feature_learning",
        "https://en.wikipedia.org/wiki/Online_machine_learning",
        "https://en.wikipedia.org/wiki/Unsupervised_learning",
        "https://en.wikipedia.org/wiki/Learning_to_rank",
        "https://en.wikipedia.org/wiki/Grammar_induction",
        "https://en.wikipedia.org/wiki/Supervised_learning",
        "https://en.wikipedia.org/wiki/Statistical_classification",
        "https://en.wikipedia.org/wiki/Regression_analysis",
        "https://en.wikipedia.org/wiki/Decision_tree_learning",
        "https://en.wikipedia.org/wiki/Ensemble_learning",
        "https://en.wikipedia.org/wiki/Bootstrap_aggregating",
        "https://en.wikipedia.org/wiki/Random_forest",
        "https://en.wikipedia.org/wiki/Linear_regression",
        "https://en.wikipedia.org/wiki/Naive_Bayes_classifier",
        "https://en.wikipedia.org/wiki/Artificial_neural_network",
        "https://en.wikipedia.org/wiki/Logistic_regression",
        "https://en.wikipedia.org/wiki/Perceptron",
        "https://en.wikipedia.org/wiki/Relevance_vector_machine",
        "https://en.wikipedia.org/wiki/Cluster_analysis",
        "https://en.wikipedia.org/wiki/BIRCH",
        "https://en.wikipedia.org/wiki/CURE_algorithm",
        "https://en.wikipedia.org/wiki/Hierarchical_clustering",
        "https://en.wikipedia.org/wiki/DBSCAN",
        "https://en.wikipedia.org/wiki/OPTICS_algorithm",
        "https://en.wikipedia.org/wiki/Mean_shift",
        "https://en.wikipedia.org/wiki/Dimensionality_reduction",
        "https://en.wikipedia.org/wiki/Factor_analysis",
        "https://en.wikipedia.org/wiki/Canonical_correlation",
        "https://en.wikipedia.org/wiki/Independent_component_analysis",
        "https://en.wikipedia.org/wiki/Linear_discriminant_analysis",
        "https://en.wikipedia.org/wiki/Principal_component_analysis",
        "https://en.wikipedia.org/wiki/Proper_generalized_decomposition",
        "https://en.wikipedia.org/wiki/Structured_prediction",
        "https://en.wikipedia.org/wiki/Graphical_model",
        "https://en.wikipedia.org/wiki/Bayesian_network",
        "https://en.wikipedia.org/wiki/Conditional_random_field",
        "https://en.wikipedia.org/wiki/Hidden_Markov_model",
        "https://en.wikipedia.org/wiki/Anomaly_detection",
        "https://en.wikipedia.org/wiki/Local_outlier_factor",
        "https://en.wikipedia.org/wiki/Artificial_neural_network",
        "https://en.wikipedia.org/wiki/Autoencoder",
        "https://en.wikipedia.org/wiki/Cognitive_computing",
        "https://en.wikipedia.org/wiki/Deep_learning",
        "https://en.wikipedia.org/wiki/DeepDream",
        "https://en.wikipedia.org/wiki/Multilayer_perceptron",
        "https://en.wikipedia.org/wiki/Gated_recurrent_unit",
        "https://en.wikipedia.org/wiki/Echo_state_network",
        "https://en.wikipedia.org/wiki/Restricted_Boltzmann_machine",
        "https://en.wikipedia.org/wiki/Generative_adversarial_network",
        "https://en.wikipedia.org/wiki/Convolutional_neural_network",
        "https://en.wikipedia.org/wiki/Vision_transformer",
        "https://en.wikipedia.org/wiki/Spiking_neural_network",
        "https://en.wikipedia.org/wiki/Memtransistor",
        "https://en.wikipedia.org/wiki/Electrochemical_RAM",
        "https://en.wikipedia.org/wiki/Reinforcement_learning",
        "https://en.wikipedia.org/wiki/Temporal_difference_learning",
        "https://en.wikipedia.org/wiki/Kernel_machines",
        "https://en.wikipedia.org/wiki/Computational_learning_theory",
        "https://en.wikipedia.org/wiki/Empirical_risk_minimization",
        "https://en.wikipedia.org/wiki/Occam_learning",
        "https://en.wikipedia.org/wiki/Probably_approximately_correct_learning",
        "https://en.wikipedia.org/wiki/Statistical_learning_theory",
        "https://en.wikipedia.org/wiki/Conference_on_Neural_Information_Processing_Systems",
        "https://en.wikipedia.org/wiki/International_Conference_on_Machine_Learning",
        "https://en.wikipedia.org/wiki/Journal_of_Machine_Learning_Research",
        "https://en.wikipedia.org/wiki/Glossary_of_artificial_intelligence",
        "https://en.wikipedia.org/wiki/Outline_of_machine_learning",
        "https://en.wikipedia.org/wiki/Artificial_neural_network",
        "https://en.wikipedia.org/wiki/Directed_graph",
        "https://en.wikipedia.org/wiki/Feedforward_neural_networks",
        "https://en.wikipedia.org/wiki/Handwriting_recognition",
        "https://en.wikipedia.org/wiki/Speech_recognition",
        "https://en.wikipedia.org/wiki/Turing_complete",
        "https://en.wikipedia.org/wiki/Infinite_impulse_response",
        "https://en.wikipedia.org/wiki/Finite_impulse_response",
        "https://en.wikipedia.org/wiki/Dynamic_system",
        "https://en.wikipedia.org/wiki/Directed_acyclic_graph",
        "https://en.wikipedia.org/wiki/Directed_cyclic_graph",
        "https://en.wikipedia.org/wiki/Gated_recurrent_unit",
        "https://en.wikipedia.org/wiki/David_Rumelhart",
        "https://en.wikipedia.org/wiki/Hopfield_network",
        "https://en.wikipedia.org/wiki/John_Hopfield",
        "https://en.wikipedia.org/wiki/Sepp_Hochreiter",
        "https://en.wikipedia.org/wiki/Speech_recognition",
        "https://en.wikipedia.org/wiki/Handwriting_recognition",
        "https://en.wikipedia.org/wiki/Baidu",
        "https://en.wikipedia.org/wiki/Google_Android",
        "https://en.wikipedia.org/wiki/Machine_translation",
        "https://en.wikipedia.org/wiki/Language_Modeling",
        "https://en.wikipedia.org/wiki/Convolutional_neural_network",
        "https://en.wikipedia.org/wiki/Automatic_image_captioning",
        "https://en.wikipedia.org/wiki/Jeff_Elman",
        "https://en.wikipedia.org/wiki/Learning_rule",
        "https://en.wikipedia.org/wiki/Multilayer_perceptron",
        "https://en.wikipedia.org/wiki/Activation_function",
        "https://en.wikipedia.org/wiki/Hopfield_network",
        "https://en.wikipedia.org/wiki/Hopfield_network",
        "https://en.wikipedia.org/wiki/Stationary_process",
        "https://en.wikipedia.org/wiki/Hebbian_learning",
        "https://en.wikipedia.org/wiki/Bidirectional_associative_memory",
        "https://en.wikipedia.org/wiki/Transpose",
        "https://en.wikipedia.org/wiki/Markov_chain",
        "https://en.wikipedia.org/wiki/Echo_state_network",
        "https://en.wikipedia.org/wiki/Time_series",
        "https://en.wikipedia.org/wiki/Spiking_neural_network",
        "https://en.wikipedia.org/wiki/Liquid_state_machine",
        "https://en.wikipedia.org/wiki/Recursive_neural_network",
        "https://en.wikipedia.org/wiki/Recursive_neural_network",
        "https://en.wikipedia.org/wiki/Recursion",
        "https://en.wikipedia.org/wiki/Topological_sort",
        "https://en.wikipedia.org/wiki/Automatic_differentiation",
        "https://en.wikipedia.org/wiki/Distributed_representation",
        "https://en.wikipedia.org/wiki/Mathematical_logic",
        "https://en.wikipedia.org/wiki/Natural_language_processing",
        "https://en.wikipedia.org/wiki/Tensor",
        "https://en.wikipedia.org/wiki/Logarithm",
        "https://en.wikipedia.org/wiki/Generative_model",
        "https://en.wikipedia.org/wiki/Vanishing_gradient_problem",
        "https://en.wikipedia.org/wiki/Automatic_differentiation",
        "https://en.wikipedia.org/wiki/Backpropagation",
        "https://en.wikipedia.org/wiki/Deep_learning",
        "https://en.wikipedia.org/wiki/Vanishing_gradient_problem",
        "https://en.wikipedia.org/wiki/Hidden_Markov_model",
        "https://en.wikipedia.org/wiki/Gated_recurrent_unit",
        "https://en.wikipedia.org/wiki/Recurrent_neural_networks",
        "https://en.wikipedia.org/wiki/Bidirectional_recurrent_neural_networks",
        "https://en.wikipedia.org/wiki/Ordinary_differential_equations",
        "https://en.wikipedia.org/wiki/Synapse",
        "https://en.wikipedia.org/wiki/Sigmoid_function",
        "https://en.wikipedia.org/wiki/Evolutionary_robotics",
        "https://en.wikipedia.org/wiki/Shannon_sampling_theorem",
        "https://en.wikipedia.org/wiki/Difference_equation",
        "https://en.wikipedia.org/wiki/Henri_Bergson",
        "https://en.wikipedia.org/wiki/Jeff_Hawkins",
        "https://en.wikipedia.org/wiki/On_Intelligence",
        "https://en.wikipedia.org/wiki/Henri_Bergson",
        "https://en.wikipedia.org/wiki/Neural_Turing_machine",
        "https://en.wikipedia.org/wiki/Memory",
        "https://en.wikipedia.org/wiki/Turing_machine",
        "https://en.wikipedia.org/wiki/Von_Neumann_architecture",
        "https://en.wikipedia.org/wiki/Differentiable_neural_computer",
        "https://en.wikipedia.org/wiki/Gradient_descent",
        "https://en.wikipedia.org/wiki/Differentiable_neural_computer",
        "https://en.wikipedia.org/wiki/Context_free_grammar",
        "https://en.wikipedia.org/wiki/HP_Labs",
        "https://en.wikipedia.org/wiki/Memristors",
        "https://en.wikipedia.org/wiki/DARPA",
        "https://en.wikipedia.org/wiki/SyNAPSE",
        "https://en.wikipedia.org/wiki/Physical_neural_network",
        "https://en.wikipedia.org/wiki/Neuromorphic_engineering",
        "https://en.wikipedia.org/wiki/Gradient_descent",
        "https://en.wikipedia.org/wiki/Iterative_algorithm",
        "https://en.wikipedia.org/wiki/Mathematical_optimization",
        "https://en.wikipedia.org/wiki/Algorithm",
        "https://en.wikipedia.org/wiki/Activation_function",
        "https://en.wikipedia.org/wiki/Differentiable_function",
        "https://en.wikipedia.org/wiki/Paul_Werbos",
        "https://en.wikipedia.org/wiki/Sepp_Hochreiter",
        "https://en.wikipedia.org/wiki/Backpropagation_through_time",
        "https://en.wikipedia.org/wiki/Automatic_differentiation",
        "https://en.wikipedia.org/wiki/Automatic_differentiation",
        "https://en.wikipedia.org/wiki/Jacobian_matrix",
        "https://en.wikipedia.org/wiki/Vanishing_gradient_problem",
        "https://en.wikipedia.org/wiki/Global_optimization",
        "https://en.wikipedia.org/wiki/Genetic_algorithm",
        "https://en.wikipedia.org/wiki/Simulated_annealing",
        "https://en.wikipedia.org/wiki/Particle_swarm_optimization",
        "https://en.wikipedia.org/wiki/Chaos_theory",
        "https://en.wikipedia.org/wiki/Dynamical_systems_theory",
        "https://en.wikipedia.org/wiki/Recursive_neural_network",
        "https://en.wikipedia.org/wiki/Finite_impulse_response",
        "https://en.wikipedia.org/wiki/Infinite_impulse_response",
        "https://en.wikipedia.org/wiki/Nonlinear_autoregressive_exogenous_model",
        "https://en.wikipedia.org/wiki/Apache_Singa",
        "https://en.wikipedia.org/wiki/MATLAB",
        "https://en.wikipedia.org/wiki/Chainer",
        "https://en.wikipedia.org/wiki/Deeplearning4j",
        "https://en.wikipedia.org/wiki/Apache_Spark",
        "https://en.wikipedia.org/wiki/Java_virtual_machine",
        "https://en.wikipedia.org/wiki/Hadoop",
        "https://en.wikipedia.org/wiki/Apache_Kafka",
        "https://en.wikipedia.org/wiki/Keras",
        "https://en.wikipedia.org/wiki/Microsoft_Cognitive_Toolkit",
        "https://en.wikipedia.org/wiki/MXNet",
        "https://en.wikipedia.org/wiki/PyTorch",
        "https://en.wikipedia.org/wiki/TensorFlow",
        "https://en.wikipedia.org/wiki/Tensor_processing_unit",
        "https://en.wikipedia.org/wiki/NumPy",
        "https://en.wikipedia.org/wiki/Machine_translation",
        "https://en.wikipedia.org/wiki/Robot_control",
        "https://en.wikipedia.org/wiki/Time_series_prediction",
        "https://en.wikipedia.org/wiki/Speech_recognition",
        "https://en.wikipedia.org/wiki/Speech_synthesis",
        "https://en.wikipedia.org/wiki/Handwriting_recognition",
        "https://en.wikipedia.org/wiki/Sepp_Hochreiter",
        "https://en.wikipedia.org/wiki/Seppo_Linnainmaa",
        "https://en.wikipedia.org/wiki/Andrea_Walther",
        "https://en.wikipedia.org/wiki/Dalle_Molle_Institute_for_Artificial_Intelligence_Research",
        "https://en.wikipedia.org/wiki/WEKA",
        "https://en.wikipedia.org/wiki/Differentiable_function",
        "https://en.wikipedia.org/wiki/Differentiable_programming",
        "https://en.wikipedia.org/wiki/Neural_Turing_machine",
        "https://en.wikipedia.org/wiki/Differentiable_neural_computer",
        "https://en.wikipedia.org/wiki/Automatic_differentiation",
        "https://en.wikipedia.org/wiki/Neuromorphic_engineering",
        "https://en.wikipedia.org/wiki/Cable_theory",
        "https://en.wikipedia.org/wiki/Pattern_recognition",
        "https://en.wikipedia.org/wiki/Computational_learning_theory",
        "https://en.wikipedia.org/wiki/Tensor_calculus",
        "https://en.wikipedia.org/wiki/Gradient_descent",
        "https://en.wikipedia.org/wiki/Stochastic_gradient_descent",
        "https://en.wikipedia.org/wiki/Cluster_analysis",
        "https://en.wikipedia.org/wiki/Regression_analysis",
        "https://en.wikipedia.org/wiki/Overfitting",
        "https://en.wikipedia.org/wiki/Adversarial_machine_learning",
        "https://en.wikipedia.org/wiki/Convolution",
        "https://en.wikipedia.org/wiki/Loss_functions_for_classification",
        "https://en.wikipedia.org/wiki/Backpropagation",
        "https://en.wikipedia.org/wiki/Batch_normalization",
        "https://en.wikipedia.org/wiki/Activation_function",
        "https://en.wikipedia.org/wiki/Softmax_function",
        "https://en.wikipedia.org/wiki/Sigmoid_function",
        "https://en.wikipedia.org/wiki/Data_augmentation",
        "https://en.wikipedia.org/wiki/Machine_learning",
        "https://en.wikipedia.org/wiki/Artificial_neural_network",
        "https://en.wikipedia.org/wiki/Deep_learning",
        "https://en.wikipedia.org/wiki/Computational_science",
        "https://en.wikipedia.org/wiki/Artificial_intelligence",
        "https://en.wikipedia.org/wiki/Graphcore",
        "https://en.wikipedia.org/wiki/Tensor_Processing_Unit",
        "https://en.wikipedia.org/wiki/Vision_processing_unit",
        "https://en.wikipedia.org/wiki/Memristor",
        "https://en.wikipedia.org/wiki/SpiNNaker",
        "https://en.wikipedia.org/wiki/TensorFlow",
        "https://en.wikipedia.org/wiki/PyTorch",
        "https://en.wikipedia.org/wiki/Keras",
        "https://en.wikipedia.org/wiki/AlexNet",
        "https://en.wikipedia.org/wiki/WaveNet",
        "https://en.wikipedia.org/wiki/Human_image_synthesis",
        "https://en.wikipedia.org/wiki/Handwriting_recognition",
        "https://en.wikipedia.org/wiki/Optical_character_recognition",
        "https://en.wikipedia.org/wiki/Speech_synthesis",
        "https://en.wikipedia.org/wiki/Speech_recognition",
        "https://en.wikipedia.org/wiki/Facial_recognition_system",
        "https://en.wikipedia.org/wiki/AlphaFold",
        "https://en.wikipedia.org/wiki/Word2vec",
        "https://en.wikipedia.org/wiki/Neural_machine_translation",
        "https://en.wikipedia.org/wiki/Project_Debater",
        "https://en.wikipedia.org/wiki/AlphaGo",
        "https://en.wikipedia.org/wiki/AlphaZero",
        "https://en.wikipedia.org/wiki/OpenAI_Five",
        "https://en.wikipedia.org/wiki/MuZero",
        "https://en.wikipedia.org/wiki/Action_selection",
        "https://en.wikipedia.org/wiki/Robot_control",
        "https://en.wikipedia.org/wiki/Ian_Goodfellow",
        "https://en.wikipedia.org/wiki/Yoshua_Bengio",
        "https://en.wikipedia.org/wiki/Geoffrey_Hinton",
        "https://en.wikipedia.org/wiki/Yann_LeCun",
        "https://en.wikipedia.org/wiki/Andrew_Ng",
        "https://en.wikipedia.org/wiki/Demis_Hassabis",
        "https://en.wikipedia.org/wiki/DeepMind",
        "https://en.wikipedia.org/wiki/OpenAI",
        "https://en.wikipedia.org/wiki/MIT_Computer_Science_and_Artificial_Intelligence_Laboratory",
        "https://en.wikipedia.org/wiki/Google_Brain",
        "https://en.wikipedia.org/wiki/Recurrent_neural_network",
        "https://en.wikipedia.org/wiki/Recurrent_neural_network",
        "https://en.wikipedia.org/wiki/Main_Page",
        "https://en.wikipedia.org/wiki/Main_Page"
    ]
}
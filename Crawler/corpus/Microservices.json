{
    "url": "https://en.wikipedia.org/wiki/Microservices",
    "title": "Microservices",
    "table_of_contents": [
        "1 Introduction",
        "2 History",
        "3 Service granularity",
        "4 Benefits",
        "5 Criticism and concerns",
        "5.1 Cognitive load",
        "6 Technologies",
        "6.1 Service mesh",
        "6.2 A comparison of platforms",
        "7 See also",
        "8 References",
        "9 Further reading"
    ],
    "content": [
        {
            "paragraph1": "A microservice architecture – a variant of the service-oriented architecture (SOA) structural style – arranges an application as a collection of loosely-coupled services. In a microservices architecture, services are fine-grained and the protocols are lightweight. The goal is that teams can bring their services to life independent of others. Loose coupling reduces all types of dependencies and the complexities around it, as service developers do not need to care about the users of the service, they do not force their changes onto users of the service. Therefore it allows organizations developing software to grow fast, and big, as well as use off the shelf services easier. Communication requirements are less. But it comes at a cost to maintain the decoupling. Interfaces need to be designed carefully and treated as a public API. Techniques like having multiple interfaces on the same service, or multiple versions of the same service, to not break existing users code.\n"
        },
        {
            "title": "Introduction",
            "paragraph1": "There is no single definition for microservices. A consensus view has evolved over time in the industry. Some of the defining characteristics that are frequently cited include:\n",
            "ul1": "Services in a microservice architecture are often processes that communicate over a network to fulfill a goal using technology-agnostic protocols such as HTTP.[1][2][3]\nServices are organized around business capabilities.[4]\nServices can be implemented using different programming languages, databases, hardware and software environments, depending on what fits best.[5]\nServices are small in size, messaging-enabled, bounded by contexts, autonomously developed, independently deployable,[6][5] decentralized and built and released with automated processes.[6]\n",
            "paragraph2": "A microservice is not a layer within a monolithic application (example, the web controller, or the backend-for-frontend). Rather, it is a self-contained piece of business functionality with clear interfaces, and may, through its own internal components, implement a layered architecture. From a strategy perspective, microservice architecture essentially follows the Unix philosophy of \"Do one thing and do it well\". Martin Fowler describes a microservices-based architecture as having the following properties:\n",
            "ul2": "Lends itself to a continuous delivery software development process. A change to a small part of the application only requires rebuilding and redeploying only one or a small number of services.[9]\nAdheres to principles such as fine-grained interfaces (to independently deployable services), business-driven development (e.g. domain-driven design).[10]\n",
            "paragraph3": "It is common for microservices architectures to be adopted for cloud-native applications, serverless computing, and applications using lightweight container deployment. According to Fowler, because of the large number (when compared to monolithic application implementations) of services, decentralized continuous delivery and DevOps with holistic service monitoring are necessary to effectively develop, maintain, and operate such applications. A consequence of (and rationale for) following this approach is that the individual microservices can be individually scaled. In the monolithic approach, an application supporting three functions would have to be scaled in its entirety even if only one of these functions had a resource constraint. With microservices, only the microservice supporting the function with resource constraints needs to be scaled out, thus providing resource and cost optimization benefits.\n"
        },
        {
            "title": "History",
            "paragraph1": "There are numerous claims as to the origin of the term microservices.\nWhilst vice president of ThoughtWorks in 2004, Fred George began working on prototype architectures based on what he called the \"Baysean Principals\" named after Jeff Bay.\n",
            "paragraph2": "As early as 2005, Peter Rodgers introduced the term \"Micro-Web-Services\" during a presentation at the Web Services Edge conference. Against conventional thinking and at the height of the SOAP SOA architecture hype curve he argued for \"REST-services\" and on slide #4 of the conference presentation, he discusses \"Software components are Micro-Web-Services\". He goes on to say \"Micro-Services are composed using Unix-like pipelines (the Web meets Unix = true loose-coupling). Services can call services (+multiple language run-times). Complex service-assemblies are abstracted behind simple URI interfaces. Any service, at any granularity, can be exposed.\" He described how a well-designed microservices platform \"applies the underlying architectural principles of the Web and REST services together with Unix-like scheduling and pipelines to provide radical flexibility and improved simplicity in service-oriented architectures.\n",
            "paragraph3": "Rodgers' work originated in 1999 with the Dexter research project at Hewlett Packard Labs, whose aim was to make code less brittle and to make large-scale, complex software systems robust to change. Ultimately this path of research led to the development of resource-oriented computing (ROC), a generalized computation abstraction in which REST is a special subset.\n",
            "paragraph4": "In 2007, Juval Löwy in his writing and speaking called for building systems in which every class was a service. Löwy realized this required the use of a technology that can support such granular use of services, and he extended Windows Communication Foundation (WCF) to do just that, taking every class and treating it as a service while maintaining the conventional programming model of classes.\n",
            "paragraph5": "A workshop of software architects held near Venice in May 2011 used the term \"microservice\" to describe what the participants saw as a common architectural style that many of them had been recently exploring. In May 2012, the same group decided on \"microservices\" as the most appropriate name. James Lewis presented some of those ideas as a case study in March 2012 at 33rd Degree in Kraków in Micro services - Java, the Unix Way, as did Fred George about the same time. Adrian Cockcroft, former director for the Cloud Systems at Netflix, described this approach as \"fine grained SOA\", pioneered the style at web scale, as did many of the others mentioned in this article - Joe Walnes, Dan North, Evan Bottcher, and Graham Tackley.\n",
            "paragraph6": "Microservices is a specialization of an implementation approach for service-oriented architectures (SOA) used to build flexible, independently deployable software systems. The microservices approach is a first realisation of SOA that followed the introduction of DevOps and is becoming more popular for building continuously deployed systems.\n",
            "paragraph7": "In February 2020, the Cloud Microservices Market Research Report predicted that the global microservice architecture market size will increase at a CAGR of 21.37% from 2019 to 2026 and reach $3.1 billion by 2026.\n"
        },
        {
            "title": "Service granularity",
            "paragraph1": "A key step in defining a microservice architecture is figuring out how big an individual microservice has to be. There is no consensus or litmus test for this, as the right answer depends on the business and organizational context. For instance, Amazon uses a service-oriented architecture where a service often maps 1:1 with a team of 3 to 10 engineers. Generally, the terminology goes as such: services that are dedicated to a single task, such as calling a particular backend system or making a particular type of calculation, are called as atomic services. Similarly, services that call such atomic services in order to consolidate an output, are called as composite services.\n",
            "paragraph2": "It is considered bad practice to make the service too small, as then the runtime overhead and the operational complexity can overwhelm the benefits of the approach. When things get too fine-grained, alternative approaches must be considered - such as packaging the function as a library, moving the function into other microservices.\n",
            "paragraph3": "If domain-driven design is being employed in modeling the domain for which the system is being built, then a microservice could be as small as an aggregate or as large as a bounded Context.\n"
        },
        {
            "title": "Benefits",
            "paragraph1": "The benefit of decomposing an application into different smaller services are numerous:\n",
            "ul1": "Modularity: This makes the application easier to understand, develop, test, and become more resilient to architecture erosion.[5] This benefit is often argued in comparison to the complexity of monolithic architectures.[33]\n",
            "ul2": "Scalability: Since microservices are implemented and deployed independently of each other, i.e. they run within independent processes, they can be monitored and scaled independently.[34]\n",
            "ul3": "Integration of heterogeneous and legacy systems: microservices is considered as a viable means for modernizing existing monolithic software application.[35][36]  There are experience reports of several companies who have successfully replaced (parts of) their existing software by microservices, or are in the process of doing so.[37] The process for Software modernization of legacy applications is done using an incremental approach.[38]\nDistributed development: it parallelizes development by enabling small autonomous teams to develop, deploy and scale their respective services independently.[39] It also allows the architecture of an individual service to emerge through continuous refactoring.[40] Microservice-based architectures facilitate continuous integration, continuous delivery and deployment.[41]\n"
        },
        {
            "title": "Criticism and concerns",
            "paragraph1": "The microservices approach is subject to criticism for a number of issues:\n",
            "ul1": "Services form information barriers.[42]\nInter-service calls over a network have a higher cost in terms of network latency and message processing time than in-process calls within a monolithic service process.[1]\nTesting and deployment are more complicated.[43][44]\nMoving responsibilities between services is more difficult.[5] It may involve communication between different teams, rewriting the functionality in another language or fitting it into a different infrastructure.[1] However, microservices can be deployed independently from the rest of the application, while teams working on monoliths need to synchronize to deploy together.[38]\nViewing the size of services as the primary structuring mechanism can lead to too many services when the alternative of internal modularization may lead to a simpler design.[45] This requires understanding the overall architecture of the applications and interdependencies between components.[46]\nTwo-phased commits are regarded as an anti-pattern in microservices-based architectures as this results in a tighter coupling of all the participants within the transaction. However, lack of this technology causes awkward dances which have to be implemented by all the transaction participants in order to maintain data consistency.[47]\nDevelopment and support of many services is more challenging if they are built with different tools and technologies - this is especially a problem if engineers move between projects frequently.[48]\nThe protocol typically used with microservices (HTTP) was designed for public-facing services, and as such is unsuitable for working internal microservices that often must be impeccably reliable.[49]\nWhile not specific to microservices, the decomposition methodology often uses functional decomposition, which does not handle changes in the requirements while still adds the complexity of services.[49]\nThe very concept of microservice is misleading, since there are only services. There is no sound definition of when a service starts or stops being a microservice.[49]\n",
            "subtitle1": "Cognitive load",
            "paragraph2": "The architecture introduces additional complexity and new problems to deal with, such as network latency, message format design, Backup/Availability/Consistency (BAC), load balancing and fault tolerance. All of these problems have to be addressed at scale.\nThe complexity of a monolithic application does not disappear if it is re-implemented as a set of microservices. Some of the complexity gets translated into operational complexity. Other places where the complexity manifests itself is in increased network traffic and resulting slower performance. Also, an application made up of any number of microservices has a larger number of interface points to access its respective ecosystem, which increases the architectural complexity. Various organizing principles (such as HATEOAS, interface and data model documentation captured via Swagger, etc.) have been applied to reduce the impact of such additional complexity.\n"
        },
        {
            "title": "Technologies",
            "paragraph1": "Computer microservices can be implemented in different programming languages and might use different infrastructures. Therefore, the most important technology choices are the way microservices communicate with each other (synchronous, asynchronous, UI integration) and the protocols used for the communication (RESTful HTTP, messaging, GraphQL ...). In a traditional system, most technology choices like the programming language impact the whole system. Therefore, the approach for choosing technologies is quite different.\n",
            "paragraph2": "The Eclipse Foundation has published a specification for developing microservices, Eclipse MicroProfile.\n",
            "subtitle1": "Service mesh",
            "paragraph3": "In a service mesh, each service instance is paired with an instance of a reverse proxy server, called a service proxy, sidecar proxy, or sidecar. The service instance and sidecar proxy share a container, and the containers are managed by a container orchestration tool such as Kubernetes, Nomad, Docker Swarm, or DC/OS.\nThe service proxies are responsible for communication with other service instances and can support capabilities such as service (instance) discovery, load balancing, authentication and authorization, secure communications, and others.\n",
            "paragraph4": "In a service mesh, the service instances and their sidecar proxies are said to make up the data plane, which includes not only data management but also request processing and response. The service mesh also includes a control plane for managing the interaction between services, mediated by their sidecar proxies. There are several options for service mesh architecture: Open Service Mesh, Istio (a joint project among Google, IBM, and Lyft), Linkerd (a CNCF project led by Buoyant), Consul (a HashiCorp product) and many others in the service mesh landscape. The service mesh management plane, Meshery, provides lifecycle, configuration, and performance management across service mesh deployments.\n",
            "subtitle2": "A comparison of platforms",
            "paragraph5": "Implementing a microservice architecture is very difficult. There are many concerns (see table below) that any microservice architecture needs to address. Netflix developed a microservice framework to support their internal applications, and then open-sourced many portions of that framework. Many of these tools have been popularized via the Spring Framework – they have been re-implemented as Spring-based tools under the umbrella of the Spring Cloud project. The table below shows a comparison of an implementing feature from the Kubernetes ecosystem with an equivalent from the Spring Cloud world. One noteworthy aspect of the Spring Cloud ecosystem is that they are all Java-based technologies, whereas Kubernetes is a polyglot runtime platform.\n"
        }
    ],
    "links": [
        "https://en.wikipedia.org/wiki/Loose_coupling",
        "https://en.wikipedia.org/wiki/Lightweight_protocol",
        "https://en.wikipedia.org/wiki/Computer_network",
        "https://en.wikipedia.org/wiki/Communications_protocol",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Database",
        "https://en.wikipedia.org/wiki/Build_automation",
        "https://en.wikipedia.org/wiki/Application_release_automation",
        "https://en.wikipedia.org/wiki/Unix_philosophy",
        "https://en.wikipedia.org/wiki/Continuous_delivery",
        "https://en.wikipedia.org/wiki/Service_granularity_principle",
        "https://en.wikipedia.org/wiki/Software_interface",
        "https://en.wikipedia.org/wiki/Cloud_application",
        "https://en.wikipedia.org/wiki/Serverless_computing",
        "https://en.wikipedia.org/wiki/DevOps",
        "https://en.wikipedia.org/wiki/ThoughtWorks",
        "https://en.wikipedia.org/wiki/Web_service",
        "https://en.wikipedia.org/wiki/SOAP",
        "https://en.wikipedia.org/wiki/Representational_state_transfer",
        "https://en.wikipedia.org/wiki/Software_component",
        "https://en.wikipedia.org/wiki/WWW",
        "https://en.wikipedia.org/wiki/Loose_coupling",
        "https://en.wikipedia.org/wiki/URI",
        "https://en.wikipedia.org/wiki/WWW",
        "https://en.wikipedia.org/wiki/Hewlett_Packard_Labs",
        "https://en.wikipedia.org/wiki/Windows_Communication_Foundation",
        "https://en.wikipedia.org/wiki/Case_study",
        "https://en.wikipedia.org/wiki/Distributed_software",
        "https://en.wikipedia.org/wiki/DevOps",
        "https://en.wikipedia.org/wiki/Continuous_deployment",
        "https://en.wikipedia.org/wiki/Compound_annual_growth_rate",
        "https://en.wikipedia.org/wiki/Modular_programming",
        "https://en.wikipedia.org/wiki/Scalability",
        "https://en.wikipedia.org/wiki/System_integration",
        "https://en.wikipedia.org/wiki/Legacy_system",
        "https://en.wikipedia.org/wiki/Software_modernization",
        "https://en.wikipedia.org/wiki/Software_development",
        "https://en.wikipedia.org/wiki/Software_deployment",
        "https://en.wikipedia.org/wiki/Refactoring",
        "https://en.wikipedia.org/wiki/Continuous_integration",
        "https://en.wikipedia.org/wiki/Continuous_delivery",
        "https://en.wikipedia.org/wiki/Function_call",
        "https://en.wikipedia.org/wiki/Monolithic_system",
        "https://en.wikipedia.org/wiki/Software_testing",
        "https://en.wikipedia.org/wiki/Software_deployment",
        "https://en.wikipedia.org/wiki/Network_latency",
        "https://en.wikipedia.org/wiki/Message_format",
        "https://en.wikipedia.org/wiki/Backup",
        "https://en.wikipedia.org/wiki/Fault_tolerance",
        "https://en.wikipedia.org/wiki/Monolithic_application",
        "https://en.wikipedia.org/wiki/Software_ecosystem",
        "https://en.wikipedia.org/wiki/HATEOAS",
        "https://en.wikipedia.org/wiki/GraphQL",
        "https://en.wikipedia.org/wiki/Eclipse_Foundation",
        "https://en.wikipedia.org/wiki/Service_mesh",
        "https://en.wikipedia.org/wiki/Kubernetes",
        "https://en.wikipedia.org/wiki/Open_Service_Mesh",
        "https://en.wikipedia.org/wiki/Cloud_Native_Computing_Foundation",
        "https://en.wikipedia.org/wiki/HashiCorp",
        "https://en.wikipedia.org/wiki/Netflix",
        "https://en.wikipedia.org/wiki/Spring_Framework",
        "https://en.wikipedia.org/wiki/Kubernetes",
        "https://en.wikipedia.org/wiki/Service_discovery",
        "https://en.wikipedia.org/wiki/Elasticsearch",
        "https://en.wikipedia.org/wiki/Kibana",
        "https://en.wikipedia.org/wiki/Elasticsearch",
        "https://en.wikipedia.org/wiki/Fluentd",
        "https://en.wikipedia.org/wiki/Kibana",
        "https://en.wikipedia.org/wiki/Grafana",
        "https://en.wikipedia.org/wiki/DevOps",
        "https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing",
        "https://en.wikipedia.org/wiki/GraphQL",
        "https://en.wikipedia.org/wiki/GRPC",
        "https://en.wikipedia.org/wiki/Representational_state_transfer",
        "https://en.wikipedia.org/wiki/Software_modernization",
        "https://en.wikipedia.org/wiki/Unix_philosophy",
        "https://en.wikipedia.org/wiki/Serverless_computing",
        "https://en.wikipedia.org/wiki/Microsoft",
        "https://en.wikipedia.org/wiki/Application_programming_interface",
        "https://en.wikipedia.org/wiki/Microservices",
        "https://en.wikipedia.org/wiki/Microservices",
        "https://en.wikipedia.org/wiki/Main_Page",
        "https://en.wikipedia.org/wiki/Main_Page"
    ]
}
{
    "url": "https://en.wikipedia.org/wiki/Programming_language_theory",
    "title": "Programming language theory",
    "table_of_contents": [
        "1 History",
        "1.1 1950s",
        "1.2 1960s",
        "1.3 1970s",
        "1.4 1980s",
        "1.5 1990s",
        "2 Sub-disciplines and related fields",
        "2.1 Formal semantics",
        "2.2 Type theory",
        "2.3 Program analysis and transformation",
        "2.4 Comparative programming language analysis",
        "2.5 Generic and metaprogramming",
        "2.6 Domain-specific languages",
        "2.7 Compiler construction",
        "2.8 Run-time systems",
        "3 Journals, publications, and conferences",
        "4 See also",
        "5 References",
        "6 Further reading",
        "7 External links"
    ],
    "content": [
        {
            "image3": {
                "url": "//upload.wikimedia.org/wikipedia/commons/thumb/3/39/Lambda_lc.svg/500px-Lambda_lc.svg.png",
                "caption": "\n\t\tThe lowercase Greek letter λ (lambda) is an unofficial symbol of the field of programming-language theory.[citation needed] This usage derives from the lambda calculus, a model of computation introduced by Alonzo Church in the 1930s and widely used by programming-language researchers. It graces the cover[citation needed] of the classic text Structure and Interpretation of Computer Programs, and the title of the so-called Lambda Papers of 1975 to 1980, written by Gerald Jay Sussman and Guy Steele, the developers of the Scheme programming language.[jargon]\n"
            },
            "paragraph1": "Programming language theory (PLT) is a branch of computer science that deals with the design, implementation, analysis, characterization, and classification of formal languages known as programming languages and of their individual features. It falls within the discipline of computer science, both depending on and affecting mathematics, software engineering, linguistics and even cognitive science. It has become a well-recognized branch of computer science, and an active research area, with results published in numerous  journals dedicated to PLT, as well as in general computer science and engineering publications.\n"
        },
        {
            "title": "History",
            "paragraph1": "In some ways, the history of programming language theory predates even the development of programming languages themselves. The lambda calculus, developed by Alonzo Church and Stephen Cole Kleene in the 1930s, is considered by some to be the world's first programming language, even though it was intended to model computation rather than being a means for programmers to describe algorithms to a computer system. Many modern functional programming languages have been described as providing a \"thin veneer\" over the lambda calculus, and many are easily described in terms of it.\n",
            "paragraph2": "The first programming language to be invented was Plankalkül, which was designed by Konrad Zuse in the 1940s, but not publicly known until 1972 (and not implemented until 1998). The first widely known and successful high-level programming language was Fortran, developed from 1954 to 1957 by a team of IBM researchers led by John Backus. The success of FORTRAN led to the formation of a committee of scientists to develop a \"universal\" computer language; the result of their effort was ALGOL 58. Separately, John McCarthy of MIT developed Lisp, the first language with origins in academia to be successful. With the success of these initial efforts, programming languages became an active topic of research in the 1960s and beyond.\n",
            "paragraph3": "Some other key events in the history of programming language theory since then:\n",
            "subtitle1": "1950s",
            "ul1": "Noam Chomsky developed the Chomsky hierarchy in the field of linguistics, a discovery which has directly impacted programming language theory and other branches of computer science.\n",
            "subtitle2": "1960s",
            "ul2": "The Simula language was developed by Ole-Johan Dahl and Kristen Nygaard; it is widely considered to be the first example of an object-oriented programming language; Simula also introduced the concept of coroutines.\nIn 1964, Peter Landin is the first to realize Church's lambda calculus can be used to model programming languages. He introduces the SECD machine which \"interprets\" lambda expressions.\nIn 1965, Landin introduces the J operator, essentially a form of continuation.\nIn 1966, Landin introduces ISWIM, an abstract computer programming language in his article The Next 700 Programming Languages. It is influential in the design of languages leading to the Haskell programming language.\nIn 1966, Corrado Böhm introduced the programming language CUCH (Curry-Church).[2]\nIn 1967, Christopher Strachey publishes his influential set of lecture notes Fundamental Concepts in Programming Languages, introducing the terminology R-values, L-values, parametric polymorphism, and ad hoc polymorphism.\nIn 1969, J. Roger Hindley publishes The Principal Type-Scheme of an Object in Combinatory Logic, later generalized into the Hindley–Milner type inference algorithm.\nIn 1969, Tony Hoare introduces the Hoare logic, a form of axiomatic semantics.\nIn 1969, William Alvin Howard observed that a \"high-level\" proof system, referred to as natural deduction, can be directly interpreted in its intuitionistic version as a typed variant of the model of computation known as lambda calculus. This became known as the Curry–Howard correspondence.\n",
            "subtitle3": "1970s",
            "ul3": "In 1970, Dana Scott first publishes his work on denotational semantics.\nIn 1972, logic programming and Prolog were developed thus allowing computer programs to be expressed as mathematical logic.\nA team of scientists at Xerox PARC led by Alan Kay develop Smalltalk, an object-oriented language widely known for its innovative development environment.\nIn 1974, John C. Reynolds discovers System F. It had already been discovered in 1971 by the mathematical logician Jean-Yves Girard.\nFrom 1975, Gerald Jay Sussman and Guy Steele develop the Scheme programming language, a Lisp dialect incorporating lexical scoping, a unified namespace, and elements from the actor model including first-class continuations.\nBackus, at the 1977 Turing Award lecture, assailed the current state of industrial languages and proposed a new class of programming languages now known as function-level programming languages.\nIn 1977, Gordon Plotkin introduces Programming Computable Functions, an abstract typed functional language.\nIn 1978, Robin Milner introduces the Hindley–Milner type inference algorithm for ML. Type theory became applied as a discipline to programming languages, this application has led to tremendous advances in type theory over the years.\n",
            "subtitle4": "1980s",
            "ul4": "In 1981, Gordon Plotkin publishes his paper on structured operational semantics.\nIn 1988, Gilles Kahn published his paper on natural semantics.\nThere emerged process calculi, such as the Calculus of Communicating Systems of Robin Milner, and the Communicating sequential processes model of C. A. R. Hoare, as well as similar models of concurrency such as the actor model of Carl Hewitt.\nIn 1985, the release of Miranda sparks an academic interest in lazy-evaluated pure functional programming languages. A committee was formed to define an open standard resulting in the release of the Haskell 1.0 standard in 1990.\nBertrand Meyer created the methodology Design by contract and incorporated it into the Eiffel programming language.\n",
            "subtitle5": "1990s",
            "ul5": "Gregor Kiczales, Jim Des Rivieres and Daniel G. Bobrow published the book The Art of the Metaobject Protocol.\nEugenio Moggi and Philip Wadler introduced the use of monads for structuring programs written in functional programming languages.\n"
        },
        {
            "title": "Sub-disciplines and related fields",
            "paragraph1": "There are several fields of study which either lie within programming language theory, or which have a profound influence on it; many of these have considerable overlap. In addition, PLT makes use of many other branches of mathematics, including computability theory, category theory, and set theory.\n",
            "subtitle1": "Formal semantics",
            "paragraph2": "Formal semantics is the formal specification of the behaviour of computer programs and programming languages. Three common approaches to describe the semantics or \"meaning\" of a computer program are denotational semantics, operational semantics and axiomatic semantics.\n",
            "subtitle2": "Type theory",
            "paragraph3": "Type theory is the study of type systems; which are \"a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute\". Many programming languages are distinguished by the characteristics of their type systems.\n",
            "subtitle3": "Program analysis and transformation",
            "paragraph4": "Program analysis is the general problem of examining a program and determining key characteristics (such as the absence of classes of program errors). Program transformation is the process of transforming a program in one form (language) to another form.\n",
            "subtitle4": "Comparative programming language analysis",
            "paragraph5": "Comparative programming language analysis seeks to classify programming languages into different types based on their characteristics; broad categories of programming languages are often known as programming paradigms.\n",
            "subtitle5": "Generic and metaprogramming",
            "paragraph6": "Metaprogramming is the generation of higher-order programs which, when executed, produce programs (possibly in a different language, or in a subset of the original language) as a result.\n",
            "subtitle6": "Domain-specific languages",
            "paragraph7": "Domain-specific languages are languages constructed to efficiently solve problems of a particular part of domain.\n",
            "subtitle7": "Compiler construction",
            "paragraph8": "Compiler theory is the theory of writing compilers (or more generally, translators); programs which translate a program written in one language into another form. The actions of a compiler are traditionally broken up into syntax analysis (scanning and parsing), semantic analysis (determining what a program should do), optimization (improving the performance of a program as indicated by some metric; typically execution speed) and code generation (generation and output of an equivalent program in some target language; often the instruction set of a CPU).\n",
            "subtitle8": "Run-time systems",
            "paragraph9": "Run-time systems refer to the development of programming language runtime environments and their components, including virtual machines, garbage collection, and foreign function interfaces.\n"
        },
        {
            "title": "Journals, publications, and conferences",
            "paragraph1": "Conferences are the primary venue for presenting research in programming languages. The most well known conferences include the Symposium on Principles of Programming Languages (POPL), Programming Language Design and Implementation (PLDI), the International Conference on Functional Programming (ICFP), the International Conference on Object Oriented Programming, Systems, Languages and Applications (OOPSLA) and the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS).\n",
            "paragraph2": "Notable journals that publish PLT research include the ACM Transactions on Programming Languages and Systems (TOPLAS), Journal of Functional Programming (JFP), Journal of Functional and Logic Programming, and Higher-Order and Symbolic Computation.\n"
        }
    ],
    "links": [
        "https://en.wikipedia.org/wiki/Theory_of_computation",
        "https://en.wikipedia.org/wiki/Greek_alphabet",
        "https://en.wikipedia.org/wiki/Lambda",
        "https://en.wikipedia.org/wiki/Lambda_calculus",
        "https://en.wikipedia.org/wiki/Model_of_computation",
        "https://en.wikipedia.org/wiki/Alonzo_Church",
        "https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs",
        "https://en.wikipedia.org/wiki/Lambda_Papers",
        "https://en.wikipedia.org/wiki/Gerald_Jay_Sussman",
        "https://en.wikipedia.org/wiki/Guy_Steele",
        "https://en.wikipedia.org/wiki/Computer_science",
        "https://en.wikipedia.org/wiki/Formal_language",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Mathematics",
        "https://en.wikipedia.org/wiki/Software_engineering",
        "https://en.wikipedia.org/wiki/Linguistics",
        "https://en.wikipedia.org/wiki/Cognitive_science",
        "https://en.wikipedia.org/wiki/Academic_journal",
        "https://en.wikipedia.org/wiki/Lambda_calculus",
        "https://en.wikipedia.org/wiki/Stephen_Cole_Kleene",
        "https://en.wikipedia.org/wiki/Model_of_computation",
        "https://en.wikipedia.org/wiki/Computer_programming",
        "https://en.wikipedia.org/wiki/Functional_programming_language",
        "https://en.wikipedia.org/wiki/Konrad_Zuse",
        "https://en.wikipedia.org/wiki/Fortran",
        "https://en.wikipedia.org/wiki/IBM",
        "https://en.wikipedia.org/wiki/John_Backus",
        "https://en.wikipedia.org/wiki/ALGOL_58",
        "https://en.wikipedia.org/wiki/MIT",
        "https://en.wikipedia.org/wiki/Noam_Chomsky",
        "https://en.wikipedia.org/wiki/Chomsky_hierarchy",
        "https://en.wikipedia.org/wiki/Simula",
        "https://en.wikipedia.org/wiki/Kristen_Nygaard",
        "https://en.wikipedia.org/wiki/Coroutine",
        "https://en.wikipedia.org/wiki/Peter_Landin",
        "https://en.wikipedia.org/wiki/SECD_machine",
        "https://en.wikipedia.org/wiki/J_operator",
        "https://en.wikipedia.org/wiki/Continuation",
        "https://en.wikipedia.org/wiki/ISWIM",
        "https://en.wikipedia.org/wiki/Programming_language",
        "https://en.wikipedia.org/wiki/Christopher_Strachey",
        "https://en.wikipedia.org/wiki/Fundamental_Concepts_in_Programming_Languages",
        "https://en.wikipedia.org/wiki/Parametric_polymorphism",
        "https://en.wikipedia.org/wiki/Ad_hoc_polymorphism",
        "https://en.wikipedia.org/wiki/Type_inference",
        "https://en.wikipedia.org/wiki/Tony_Hoare",
        "https://en.wikipedia.org/wiki/Hoare_logic",
        "https://en.wikipedia.org/wiki/Axiomatic_semantics",
        "https://en.wikipedia.org/wiki/William_Alvin_Howard",
        "https://en.wikipedia.org/wiki/Proof_calculus",
        "https://en.wikipedia.org/wiki/Natural_deduction",
        "https://en.wikipedia.org/wiki/Intuitionistic",
        "https://en.wikipedia.org/wiki/Model_of_computation",
        "https://en.wikipedia.org/wiki/Lambda_calculus",
        "https://en.wikipedia.org/wiki/Dana_Scott",
        "https://en.wikipedia.org/wiki/Denotational_semantics",
        "https://en.wikipedia.org/wiki/Logic_programming",
        "https://en.wikipedia.org/wiki/Prolog",
        "https://en.wikipedia.org/wiki/Xerox_PARC",
        "https://en.wikipedia.org/wiki/Alan_Kay",
        "https://en.wikipedia.org/wiki/Smalltalk",
        "https://en.wikipedia.org/wiki/System_F",
        "https://en.wikipedia.org/wiki/Gerald_Jay_Sussman",
        "https://en.wikipedia.org/wiki/Guy_Steele",
        "https://en.wikipedia.org/wiki/Lexical_scoping",
        "https://en.wikipedia.org/wiki/Actor_model",
        "https://en.wikipedia.org/wiki/Continuation",
        "https://en.wikipedia.org/wiki/Turing_Award",
        "https://en.wikipedia.org/wiki/Gordon_Plotkin",
        "https://en.wikipedia.org/wiki/Programming_Computable_Functions",
        "https://en.wikipedia.org/wiki/Robin_Milner",
        "https://en.wikipedia.org/wiki/Type_theory",
        "https://en.wikipedia.org/wiki/Gordon_Plotkin",
        "https://en.wikipedia.org/wiki/Structured_operational_semantics",
        "https://en.wikipedia.org/wiki/Gilles_Kahn",
        "https://en.wikipedia.org/wiki/Natural_semantics",
        "https://en.wikipedia.org/wiki/Process_calculus",
        "https://en.wikipedia.org/wiki/Calculus_of_Communicating_Systems",
        "https://en.wikipedia.org/wiki/Robin_Milner",
        "https://en.wikipedia.org/wiki/Communicating_sequential_processes",
        "https://en.wikipedia.org/wiki/Actor_model",
        "https://en.wikipedia.org/wiki/Carl_Hewitt",
        "https://en.wikipedia.org/wiki/Bertrand_Meyer",
        "https://en.wikipedia.org/wiki/Design_by_contract",
        "https://en.wikipedia.org/wiki/Gregor_Kiczales",
        "https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol",
        "https://en.wikipedia.org/wiki/Eugenio_Moggi",
        "https://en.wikipedia.org/wiki/Philip_Wadler",
        "https://en.wikipedia.org/wiki/Monads_in_functional_programming",
        "https://en.wikipedia.org/wiki/Functional_programming_language",
        "https://en.wikipedia.org/wiki/Mathematics",
        "https://en.wikipedia.org/wiki/Computability_theory",
        "https://en.wikipedia.org/wiki/Category_theory",
        "https://en.wikipedia.org/wiki/Set_theory",
        "https://en.wikipedia.org/wiki/Formal_semantics_of_programming_languages",
        "https://en.wikipedia.org/wiki/Denotational_semantics",
        "https://en.wikipedia.org/wiki/Operational_semantics",
        "https://en.wikipedia.org/wiki/Axiomatic_semantics",
        "https://en.wikipedia.org/wiki/Type_theory",
        "https://en.wikipedia.org/wiki/Type_system",
        "https://en.wikipedia.org/wiki/Program_analysis",
        "https://en.wikipedia.org/wiki/Program_transformation",
        "https://en.wikipedia.org/wiki/Software_bug",
        "https://en.wikipedia.org/wiki/Programming_paradigm",
        "https://en.wikipedia.org/wiki/Metaprogramming",
        "https://en.wikipedia.org/wiki/Compiler_construction",
        "https://en.wikipedia.org/wiki/Compiler",
        "https://en.wikipedia.org/wiki/Parsing",
        "https://en.wikipedia.org/wiki/Compiler_optimization",
        "https://en.wikipedia.org/wiki/Instruction_set",
        "https://en.wikipedia.org/wiki/Runtime_environment",
        "https://en.wikipedia.org/wiki/Virtual_machine",
        "https://en.wikipedia.org/wiki/Foreign_function_interface",
        "https://en.wikipedia.org/wiki/Symposium_on_Principles_of_Programming_Languages",
        "https://en.wikipedia.org/wiki/Conference_on_Programming_Language_Design_and_Implementation",
        "https://en.wikipedia.org/wiki/International_Conference_on_Functional_Programming",
        "https://en.wikipedia.org/wiki/OOPSLA",
        "https://en.wikipedia.org/wiki/International_Conference_on_Architectural_Support_for_Programming_Languages_and_Operating_Systems",
        "https://en.wikipedia.org/wiki/ACM_Transactions_on_Programming_Languages_and_Systems",
        "https://en.wikipedia.org/wiki/Journal_of_Functional_Programming",
        "https://en.wikipedia.org/wiki/Journal_of_Functional_Programming",
        "https://en.wikipedia.org/wiki/SIGPLAN",
        "https://en.wikipedia.org/wiki/Timeline_of_programming_languages",
        "https://en.wikipedia.org/wiki/Luca_Cardelli",
        "https://en.wikipedia.org/wiki/Donald_Knuth",
        "https://en.wikipedia.org/wiki/University_of_Pennsylvania",
        "https://en.wikipedia.org/wiki/Carnegie_Mellon_University",
        "https://en.wikipedia.org/wiki/Mark_Leone",
        "https://en.wikipedia.org/wiki/POPL",
        "https://en.wikipedia.org/wiki/Programming_language_theory",
        "https://en.wikipedia.org/wiki/Programming_language_theory",
        "https://en.wikipedia.org/wiki/Main_Page",
        "https://en.wikipedia.org/wiki/Main_Page"
    ]
}